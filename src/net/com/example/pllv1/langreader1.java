package net.com.example.pllv1;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Calendar;
import java.util.TimeZone;

import android.app.ActionBar;
import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.graphics.Color;
import android.media.MediaPlayer;
import android.os.Bundle;
import android.os.PowerManager;
import android.os.PowerManager.WakeLock;
import android.os.Vibrator;
import android.preference.PreferenceManager;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.Window;
import android.view.WindowManager;
import android.widget.Button;
import android.widget.EditText;
import android.widget.SlidingDrawer;
import android.widget.SlidingDrawer.OnDrawerCloseListener;
import android.widget.SlidingDrawer.OnDrawerOpenListener;
//import android.widget.SlidingDrawer;
import android.widget.TextView;
import android.widget.Toast;

public class langreader1 extends Activity  implements OnClickListener, OnDrawerOpenListener, OnDrawerCloseListener {


		
	TextView t,t1;EditText editnotes;
	Button booksave,bookdisplay,savenotes,displaynotes;
	@SuppressWarnings("deprecation")
	SlidingDrawer sd;
	int ii = 0;
	Button prev, next;
	SharedPreferences bookmark;
	String var;
	String optionsc[] = { "INTRO", "Basic Input/Output", "Variables. Data Types",
			"Operators", "Simple control structures", "Arrays", "Pointers", "Dynamic Memory","Classes (I)","Classes (II)","Friendship and inheritance", "Exceptions" };
	String optionscvalues[] = { "This tutorial is for those people who want to learn programming in C++ and do not necessarily have any previous knowledge of other programming languages. Of course any knowledge of other programming languages or any general computer skill can be useful to better understand this tutorial, although it is not essential.\n\nIt is also suitable for those who need a little update on the new features the language has acquired from the latest standards.\n\nIf you are familiar with the C language, you can take the first three parts of this tutorial as a review of concepts, since they mainly explain the C part of C++. There are slight differences in the C++ \nsyntax for some C features, so I still recommend you to read them.","Standard Output (cout)\nBy default, the standard output of a program is the screen, and the C++ stream object defined to access it is cout.\n\ncout is used in conjunction with the insertion operator, which is written as << (two \"less than\" signs).\n\n1\n2\n3\ncout << \"Output sentence\"; // prints Output sentence on screen\ncout << 120; // prints number 120 on screen\ncout << x; // prints the content of x on screen \n\n\nThe << operator inserts the data that follows it into the stream preceding it. In the examples above it inserted the constant string Output sentence, the numerical constant 120 and variable x into the standard output stream cout. Notice that the sentence in the first instruction is enclosed between double quotes (\") because it is a constant string of characters. Whenever we want to use constant strings of characters we must enclose them between double quotes (\") so that they can be clearly distinguished from variable names. For example, these two sentences have very different results:\n\n1\n2\ncout << \"Hello\"; // prints Hello\ncout << Hello; // prints the content of Hello variable \n\n\nThe insertion operator (<<) may be used more than once in a single statement:\n\n \ncout << \"Hello, \" << \"I am \" << \"a C++ statement\";\n\n\nThis last statement would print the message Hello, I am a C++ statement on the screen. The utility of repeating the insertion operator (<<) is demonstrated when we want to print out a combination of variables and constants or more than one variable:\n\n \ncout << \"Hello, I am \" << age << \" years old and my zipcode is \" << zipcode;\n\n\nIf we assume the age variable to contain the value 24 and the zipcode variable to contain 90064 the output of the previous statement would be: \n\n \nHello, I am 24 years old and my zipcode is 90064 \n\n\nIt is important to notice that cout does not add a line break after its output unless we explicitly indicate it, therefore, the following statements:\n\n1\n2\ncout << \"This is a sentence.\";\ncout << \"This is another sentence.\"; \n\n\nwill be shown on the screen one following the other without any line break between them:\n\nThis is a sentence.This is another sentence. \n\neven though we had written them in two different insertions into cout. In order to perform a line break on the output we must explicitly insert a new-line character into cout. In C++ a new-line character can be specified as \\n (backslash, n):\n\n1\n2\ncout << \"First sentence.\\n\";\ncout << \"Second sentence.\\nThird sentence.\"; \n\n\nThis produces the following output: \n\nFirst sentence.\nSecond sentence.\nThird sentence.\n\nAdditionally, to add a new-line, you may also use the endl manipulator. For example: \n\n1\n2\ncout << \"First sentence.\" << endl;\ncout << \"Second sentence.\" << endl; \n\n\nwould print out: \n\nFirst sentence.\nSecond sentence. \n\nThe endl manipulator produces a newline character, exactly as the insertion of \'\\n\' does, but it also has an additional behavior when it is used with buffered streams: the buffer is flushed. Anyway, cout will be an unbuffered stream in most cases, so you can generally use both the \\n escape character and the endl manipulator in order to specify a new line without any difference in its behavior.\n\nStandard Input (cin).\nThe standard input device is usually the keyboard. Handling the standard input in C++ is done by applying the overloaded operator of extraction (>>) on the cin stream. The operator must be followed by the variable that will store the data that is going to be extracted from the stream. For example:\n\n1\n2\nint age;\ncin >> age; \n\n\nThe first statement declares a variable of type int called age, and the second one waits for an input from cin (the keyboard) in order to store it in this integer variable.\n\ncin can only process the input from the keyboard once the RETURN key has been pressed. Therefore, even if you request a single character, the extraction from cin will not process the input until the user presses RETURN after the character has been introduced.\n\nYou must always consider the type of the variable that you are using as a container with cin extractions. If you request an integer you will get an integer, if you request a character you will get a character and if you request a string of characters you will get a string of characters. \n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n// i/o example\n\n#include <iostream>\nusing namespace std;\n\nint main ()\n{\n int i;\n cout << \"Please enter an integer value: \";\n cin >> i;\n cout << \"The value you entered is \" << i;\n cout << \" and its double is \" << i*2 << \".\\n\";\n return 0;\n}\nPlease enter an integer value: 702\nThe value you entered is 702 and its double is 1404.\n\n\nThe user of a program may be one of the factors that generate errors even in the simplest programs that use cin (like the one we have just seen). Since if you request an integer value and the user introduces a name (which generally is a string of characters), the result may cause your program to misoperate since it is not what we were expecting from the user. So when you use the data input provided by cin extractions you will have to trust that the user of your program will be cooperative and that he/she will not introduce his/her name or something similar when an integer value is requested. A little ahead, when we see the stringstream class we will see a possible solution for the errors that can be caused by this type of user input.\n\nYou can also use cin to request more than one datum input from the user: \n\n \ncin >> a >> b;\n\n\nis equivalent to:\n\n1\n2\ncin >> a;\ncin >> b;\n\n\nIn both cases the user must give two data, one for variable a and another one for variable b that may be separated by any valid blank separator: a space, a tab character or a newline.\n\ncin and strings\nWe can use cin to get strings with the extraction operator (>>) as we do with fundamental data type variables:\n\n \ncin >> mystring;\n\n\nHowever, as it has been said, cin extraction stops reading as soon as if finds any blank space character, so in this case we will be able to get just one word for each extraction. This behavior may or may not be what we want; for example if we want to get a sentence from the user, this extraction operation would not be useful.\n\nIn order to get entire lines, we can use the function getline, which is the more recommendable way to get user input with cin:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n// cin with strings\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main ()\n{\n string mystr;\n cout << \"What\'s your name? \";\n getline (cin, mystr);\n cout << \"Hello \" << mystr << \".\\n\";\n cout << \"What is your favorite team? \";\n getline (cin, mystr);\n cout << \"I like \" << mystr << \" too!\\n\";\n return 0;\n}\nWhat\'s your name? Juan Soulie\nHello Juan Soulie.\nWhat is your favorite team? The Isotopes\nI like The Isotopes too!\n\n\nNotice how in both calls to getline we used the same string identifier (mystr). What the program does in the second call is simply to replace the previous content by the new one that is introduced.\n\nstringstream\nThe standard header file <sstream> defines a class called stringstream that allows a string-based object to be treated as a stream. This way we can perform extraction or insertion operations from/to strings, which is especially useful to convert strings to numerical values and vice versa. For example, if we want to extract an integer from a string we can write:\n\n1\n2\n3\nstring mystr (\"1204\");\nint myint;\nstringstream(mystr) >> myint;\n\n\nThis declares a string object with a value of \"1204\", and an int object. Then we use stringstream\'s constructor to construct an object of this type from the string object. Because we can use stringstream objects as if they were streams, we can extract an integer from it as we would have done on cin by applying the extractor operator (>>) on it followed by a variable of type int.\n\nAfter this piece of code, the variable myint will contain the numerical value 1204.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n// stringstreams\n#include <iostream>\n#include <string>\n#include <sstream>\nusing namespace std;\n\nint main ()\n{\n string mystr;\n float price=0;\n int quantity=0;\n\n cout << \"Enter price: \";\n getline (cin,mystr);\n stringstream(mystr) >> price;\n cout << \"Enter quantity: \";\n getline (cin,mystr);\n stringstream(mystr) >> quantity;\n cout << \"Total price: \" << price*quantity << endl;\n return 0;\n}\nEnter price: 22.25\nEnter quantity: 7\nTotal price: 155.75\n\n\nIn this example, we acquire numeric values from the standard input indirectly. Instead of extracting numeric values directly from the standard input, we get lines from the standard input (cin) into a string object (mystr), and then we extract the integer values from this string into a variable of type int (quantity).\n\nUsing this method, instead of direct extractions of integer values, we have more control over what happens with the input of numeric values from the user, since we are separating the process of obtaining input from the user (we now simply ask for lines) with the interpretation of that input. Therefore, this method is usually preferred to get numerical values from the user in all programs that are intensive in user input.","The usefulness of the \"Hello World\" programs shown in the previous section is quite questionable. We had to write several lines of code, compile them, and then execute the resulting program just to obtain a simple sentence written on the screen as result. It certainly would have been much faster to type the output sentence by ourselves. However, programming is not limited only to printing simple texts on the screen. In order to go a little further on and to become able to write programs that perform useful tasks that really save us work we need to introduce the concept of variable.\n\nLet us think that I ask you to retain the number 5 in your mental memory, and then I ask you to memorize also the number 2 at the same time. You have just stored two different values in your memory. Now, if I ask you to add 1 to the first number I said, you should be retaining the numbers 6 (that is 5+1) and 2 in your memory. Values that we could now -for example- subtract and obtain 4 as result.\n\nThe whole process that you have just done with your mental memory is a simile of what a computer can do with two variables. The same process can be expressed in C++ with the following instruction set: \n\n1\n2\n3\n4\na = 5;\nb = 2;\na = a + 1;\nresult = a - b;\n\n\nObviously, this is a very simple example since we have only used two small integer values, but consider that your computer can store millions of numbers like these at the same time and conduct sophisticated mathematical operations with them.\n\nTherefore, we can define a variable as a portion of memory to store a determined value.\n\nEach variable needs an identifier that distinguishes it from the others. For example, in the previous code the variable identifiers were a, b and result, but we could have called the variables any names we wanted to invent, as long as they were valid identifiers.\n\nIdentifiers\nA valid identifier is a sequence of one or more letters, digits or underscore characters (_). Neither spaces nor punctuation marks or symbols can be part of an identifier. Only letters, digits and single underscore characters are valid. In addition, variable identifiers always have to begin with a letter. They can also begin with an underline character (_ ), but in some cases these may be reserved for compiler specific keywords or external identifiers, as well as identifiers containing two successive underscore characters anywhere. In no case can they begin with a digit.\n\nAnother rule that you have to consider when inventing your own identifiers is that they cannot match any keyword of the C++ language nor your compiler\'s specific ones, which are reserved keywords. The standard reserved keywords are:\n\nasm, auto, bool, break, case, catch, char, class, const, const_cast, continue, default, delete, do, double, dynamic_cast, else, enum, explicit, export, extern, false, float, for, friend, goto, if, inline, int, long, mutable, namespace, new, operator, private, protected, public, register, reinterpret_cast, return, short, signed, sizeof, static, static_cast, struct, switch, template, this, throw, true, try, typedef, typeid, typename, union, unsigned, using, virtual, void, volatile, wchar_t, while \n\nAdditionally, alternative representations for some operators cannot be used as identifiers since they are reserved words under some circumstances: \n\nand, and_eq, bitand, bitor, compl, not, not_eq, or, or_eq, xor, xor_eq \n\nYour compiler may also include some additional specific reserved keywords.\n\nVery important: The C++ language is a \"case sensitive\" language. That means that an identifier written in capital letters is not equivalent to another one with the same name but written in small letters. Thus, for example, the RESULT variable is not the same as the result variable or the Result variable. These are three different variable identifiers.\n\nFundamental data types\nWhen programming, we store the variables in our computer\'s memory, but the computer has to know what kind of data we want to store in them, since it is not going to occupy the same amount of memory to store a simple number than to store a single letter or a large number, and they are not going to be interpreted the same way.\n\nThe memory in our computers is organized in bytes. A byte is the minimum amount of memory that we can manage in C++. A byte can store a relatively small amount of data: one single character or a small integer (generally an integer between 0 and 255). In addition, the computer can manipulate more complex data types that come from grouping several bytes, such as long numbers or non-integer numbers.\n\nNext you have a summary of the basic fundamental data types in C++, as well as the range of values that can be represented with each one:\n\nName\tDescription\tSize*\tRange*\nchar\tCharacter or small integer.\t1byte\tsigned: -128 to 127\nunsigned: 0 to 255\nshort int (short)\tShort Integer.\t2bytes\tsigned: -32768 to 32767\nunsigned: 0 to 65535\nint\tInteger.\t4bytes\tsigned: -2147483648 to 2147483647\nunsigned: 0 to 4294967295\nlong int (long)\tLong integer.\t4bytes\tsigned: -2147483648 to 2147483647\nunsigned: 0 to 4294967295\nbool\tBoolean value. It can take one of two values: true or false.\t1byte\ttrue or false\nfloat\tFloating point number.\t4bytes\t+/- 3.4e +/- 38 (~7 digits)\ndouble\tDouble precision floating point number.\t8bytes\t+/- 1.7e +/- 308 (~15 digits)\nlong double\tLong double precision floating point number.\t8bytes\t+/- 1.7e +/- 308 (~15 digits)\nwchar_t\tWide character.\t2 or 4 bytes\t1 wide character\n\n* The values of the columns Size and Range depend on the system the program is compiled for. The values shown above are those found on most 32-bit systems. But for other systems, the general specification is that int has the natural size suggested by the system architecture (one \"word\") and the four integer types char, short, int and long must each one be at least as large as the one preceding it, with char being always one byte in size. The same applies to the floating point types float, double and long double, where each one must provide at least as much precision as the preceding one.\n\nDeclaration of variables\nIn order to use a variable in C++, we must first declare it specifying which data type we want it to be. The syntax to declare a new variable is to write the specifier of the desired data type (like int, bool, float...) followed by a valid variable identifier. For example:\n\n1\n2\nint a;\nfloat mynumber;\n\n\nThese are two valid declarations of variables. The first one declares a variable of type int with the identifier a. The second one declares a variable of type float with the identifier mynumber. Once declared, the variables a and mynumber can be used within the rest of their scope in the program.\n\nIf you are going to declare more than one variable of the same type, you can declare all of them in a single statement by separating their identifiers with commas. For example:\n\n \nint a, b, c;\n\n\nThis declares three variables (a, b and c), all of them of type int, and has exactly the same meaning as:\n\n1\n2\n3\nint a;\nint b;\nint c;\n\n\nThe integer data types char, short, long and int can be either signed or unsigned depending on the range of numbers needed to be represented. Signed types can represent both positive and negative values, whereas unsigned types can only represent positive values (and zero). This can be specified by using either the specifier signed or the specifier unsigned before the type name. For example: \n\n1\n2\nunsigned short int NumberOfSisters;\nsigned int MyAccountBalance;\n\n\nBy default, if we do not specify either signed or unsigned most compiler settings will assume the type to be signed, therefore instead of the second declaration above we could have written:\n\n \nint MyAccountBalance;\n\n\nwith exactly the same meaning (with or without the keyword signed)\n\nAn exception to this general rule is the char type, which exists by itself and is considered a different fundamental data type from signed char and unsigned char, thought to store characters. You should use either signed or unsigned if you intend to store numerical values in a char-sized variable.\n\nshort and long can be used alone as type specifiers. In this case, they refer to their respective integer fundamental types: short is equivalent to short int and long is equivalent to long int. The following two variable declarations are equivalent:\n\n1\n2\nshort Year;\nshort int Year;\n\n\nFinally, signed and unsigned may also be used as standalone type specifiers, meaning the same as signed int and unsigned int respectively. The following two declarations are equivalent: \n\n1\n2\nunsigned NextYear;\nunsigned int NextYear;\n\n\nTo see what variable declarations look like in action within a program, we are going to see the C++ code of the example about your mental memory proposed at the beginning of this section:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n// operating with variables\n\n#include <iostream>\nusing namespace std;\n\nint main ()\n{\n // declaring variables:\n int a, b;\n int result;\n\n // process:\n a = 5;\n b = 2;\n a = a + 1;\n result = a - b;\n\n // print out the result:\n cout << result;\n\n // terminate the program:\n return 0;\n}\n4\n\n\nDo not worry if something else than the variable declarations themselves looks a bit strange to you. You will see the rest in detail in coming sections. \n\nScope of variables\nAll the variables that we intend to use in a program must have been declared with its type specifier in an earlier point in the code, like we did in the previous code at the beginning of the body of the function main when we declared that a, b, and result were of type int.\n\nA variable can be either of global or local scope. A global variable is a variable declared in the main body of the source code, outside all functions, while a local variable is one declared within the body of a function or a block.\n\n \nGlobal variables can be referred from anywhere in the code, even inside functions, whenever it is after its declaration.\n\nThe scope of local variables is limited to the block enclosed in braces ({}) where they are declared. For example, if they are declared at the beginning of the body of a function (like in function main) their scope is between its declaration point and the end of that function. In the example above, this means that if another function existed in addition to main, the local variables declared in main could not be accessed from the other function and vice versa.\n\nInitialization of variables\nWhen declaring a regular local variable, its value is by default undetermined. But you may want a variable to store a concrete value at the same moment that it is declared. In order to do that, you can initialize the variable. There are two ways to do this in C++:\n\nThe first one, known as c-like initialization, is done by appending an equal sign followed by the value to which the variable will be initialized:\n\ntype identifier = initial_value ; \nFor example, if we want to declare an int variable called a initialized with a value of 0 at the moment in which it is declared, we could write:\n\n \nint a = 0;\n\n\nThe other way to initialize variables, known as constructor initialization, is done by enclosing the initial value between parentheses (()): \n\ntype identifier (initial_value) ; \nFor example:\n\n \nint a (0); \n\n\nBoth ways of initializing variables are valid and equivalent in C++.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n// initialization of variables\n\n#include <iostream>\nusing namespace std;\n\nint main ()\n{\n int a=5; // initial value = 5\n int b(2); // initial value = 2\n int result; // initial value undetermined\n\n a = a + 3;\n result = a - b;\n cout << result;\n\n return 0;\n}\n6\n\n\nIntroduction to strings\nVariables that can store non-numerical values that are longer than one single character are known as strings.\n\nThe C++ language library provides support for strings through the standard string class. This is not a fundamental type, but it behaves in a similar way as fundamental types do in its most basic usage.\n\nA first difference with fundamental data types is that in order to declare and use objects (variables) of this type we need to include an additional header file in our source code: <string> and have access to the std namespace (which we already had in all our previous programs thanks to the using namespace statement).\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n// my first string\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main ()\n{\n string mystring = \"This is a string\";\n cout << mystring;\n return 0;\n}\nThis is a string\n\n\nAs you may see in the previous example, strings can be initialized with any valid string literal just like numerical type variables can be initialized to any valid numerical literal. Both initialization formats are valid with strings:\n\n1\n2\nstring mystring = \"This is a string\";\nstring mystring (\"This is a string\");\n\n\nStrings can also perform all the other basic operations that fundamental data types can, like being declared without an initial value and being assigned values during execution:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n// my first string\n#include <iostream>\n#include <string>\nusing namespace std;\n\nint main ()\n{\n string mystring;\n mystring = \"This is the initial string content\";\n cout << mystring << endl;\n mystring = \"This is a different string content\";\n cout << mystring << endl;\n return 0;\n}\nThis is the initial string content\nThis is a different string content","Literals\nLiterals are the most obvious kind of constants. They are used to express particular values within the source code of a program. We have already used these previously to give concrete values to variables or to express messages we wanted our programs to print out, for example, when we wrote:\n\n \na = 5;\n\n\nthe 5 in this piece of code was a literal constant.\n\nLiteral constants can be divided in Integer Numerals, Floating-Point Numerals, Characters, Strings and Boolean Values.\n\nInteger Numerals\n\n1\n2\n3\n1776\n707\n-273\n\n\nThey are numerical constants that identify integer decimal values. Notice that to express a numerical constant we do not have to write quotes (\") nor any special character. There is no doubt that it is a constant: whenever we write 1776 in a program, we will be referring to the value 1776.\n\nIn addition to decimal numbers (those that all of us are used to using every day), C++ allows the use of octal numbers (base 8) and hexadecimal numbers (base 16) as literal constants. If we want to express an octal number we have to precede it with a 0 (a zero character). And in order to express a hexadecimal number we have to precede it with the characters 0x (zero, x). For example, the following literal constants are all equivalent to each other: \n\n1\n2\n3\n75 // decimal\n0113 // octal\n0x4b // hexadecimal \n\n\nAll of these represent the same number: 75 (seventy-five) expressed as a base-10 numeral, octal numeral and hexadecimal numeral, respectively. \n\nLiteral constants, like variables, are considered to have a specific data type. By default, integer literals are of type int. However, we can force them to either be unsigned by appending the u character to it, or long by appending l:\n\n1\n2\n3\n4\n75 // int\n75u // unsigned int\n75l // long\n75ul // unsigned long \n\n\nIn both cases, the suffix can be specified using either upper or lowercase letters.\n\nFloating Point Numbers\nThey express numbers with decimals and/or exponents. They can include either a decimal point, an e character (that expresses \"by ten at the Xth height\", where X is an integer value that follows the e character), or both a decimal point and an e character:\n\n1\n2\n3\n4\n3.14159 // 3.14159\n6.02e23 // 6.02 x 10^23\n1.6e-19 // 1.6 x 10^-19\n3.0 // 3.0 \n\n\nThese are four valid numbers with decimals expressed in C++. The first number is PI, the second one is the number of Avogadro, the third is the electric charge of an electron (an extremely small number) -all of them approximated- and the last one is the number three expressed as a floating-point numeric literal.\n\nThe default type for floating point literals is double. If you explicitly want to express a float or a long double numerical literal, you can use the f or l suffixes respectively:\n\n1\n2\n3.14159L // long double\n6.02e23f // float \n\n\nAny of the letters that can be part of a floating-point numerical constant (e, f, l) can be written using either lower or uppercase letters without any difference in their meanings.\n\nCharacter and string literals\nThere also exist non-numerical constants, like: \n\n1\n2\n3\n4\n\'z\'\n\'p\'\n\"Hello world\"\n\"How do you do?\" \n\n\nThe first two expressions represent single character constants, and the following two represent string literals composed of several characters. Notice that to represent a single character we enclose it between single quotes (\') and to express a string (which generally consists of more than one character) we enclose it between double quotes (\"). \n\nWhen writing both single character and string literals, it is necessary to put the quotation marks surrounding them to distinguish them from possible variable identifiers or reserved keywords. Notice the difference between these two expressions: \n\n1\n2\nx\n\'x\'\n\n\nx alone would refer to a variable whose identifier is x, whereas \'x\' (enclosed within single quotation marks) would refer to the character constant \'x\'.\n\nCharacter and string literals have certain peculiarities, like the escape codes. These are special characters that are difficult or impossible to express otherwise in the source code of a program, like newline (\\n) or tab (\\t). All of them are preceded by a backslash (\\). Here you have a list of some of such escape codes: \n\n\\n\tnewline\n\\r\tcarriage return\n\\t\ttab\n\\v\tvertical tab\n\\b\tbackspace\n\\f\tform feed (page feed)\n\\a\talert (beep)\n\\\'\tsingle quote (\')\n\\\"\tdouble quote (\")\n\\?\tquestion mark (?)\n\\\\\tbackslash (\\)\n\nFor example: \n\n1\n2\n3\n4\n\'\\n\'\n\'\\t\'\n\"Left \\t Right\"\n\"one\\ntwo\\nthree\" \n\n\nAdditionally, you can express any character by its numerical ASCII code by writing a backslash character (\\) followed by the ASCII code expressed as an octal (base-8) or hexadecimal (base-16) number. In the first case (octal) the digits must immediately follow the backslash (for example \\23 or \\40), in the second case (hexadecimal), an x character must be written before the digits themselves (for example \\x20 or \\x4A).\n\nString literals can extend to more than a single line of code by putting a backslash sign (\\) at the end of each unfinished line.\n\n1\n2\n\"string expressed in \\\ntwo lines\" \n\n\nYou can also concatenate several string constants separating them by one or several blank spaces, tabulators, newline or any other valid blank character: \n\n \n\"this forms\" \"a single\" \"string\" \"of characters\"\n\n\nFinally, if we want the string literal to be explicitly made of wide characters (wchar_t type), instead of narrow characters (char type), we can precede the constant with the L prefix:\n\n \nL\"This is a wide character string\"\n\n\nWide characters are used mainly to represent non-English or exotic character sets.\n\nBoolean literals\nThere are only two valid Boolean values: true and false. These can be expressed in C++ as values of type bool by using the Boolean literals true and false.\n\nDefined constants (#define)\nYou can define your own names for constants that you use very often without having to resort to memory-consuming variables, simply by using the #define preprocessor directive. Its format is:\n\n#define identifier value \nFor example: \n\n1\n2\n#define PI 3.14159\n#define NEWLINE \'\\n\' \n\n\nThis defines two new constants: PI and NEWLINE. Once they are defined, you can use them in the rest of the code as if they were any other regular constant, for example: \n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n// defined constants: calculate circumference\n\n#include <iostream>\nusing namespace std;\n\n#define PI 3.14159\n#define NEWLINE \'\\n\'\n\nint main ()\n{\n double r=5.0; // radius\n double circle;\n\n circle = 2 * PI * r;\n cout << circle;\n cout << NEWLINE;\n\n return 0;\n}\n31.4159\n\n\nIn fact the only thing that the compiler preprocessor does when it encounters #define directives is to literally replace any occurrence of their identifier (in the previous example, these were PI and NEWLINE) by the code to which they have been defined (3.14159 and \'\\n\' respectively).\n\nThe #define directive is not a C++ statement but a directive for the preprocessor; therefore it assumes the entire line as the directive and does not require a semicolon (;) at its end. If you append a semicolon character (;) at the end, it will also be appended in all occurrences of the identifier within the body of the program that the preprocessor replaces.\n\nDeclared constants (const)\nWith the const prefix you can declare constants with a specific type in the same way as you would do with a variable: \n\n1\n2\nconst int pathwidth = 100;\nconst char tabulator = \'\\t\';","Once we know of the existence of variables and constants, we can begin to operate with them. For that purpose, C++ integrates operators. Unlike other languages whose operators are mainly keywords, operators in C++ are mostly made of signs that are not part of the alphabet but are available in all keyboards. This makes C++ code shorter and more international, since it relies less on English words, but requires a little of learning effort in the beginning.\n\nYou do not have to memorize all the content of this page. Most details are only provided to serve as a later reference in case you need it. \n\nAssignment (=)\nThe assignment operator assigns a value to a variable.\n\n \na = 5;\n\n\nThis statement assigns the integer value 5 to the variable a. The part at the left of the assignment operator (=) is known as the lvalue (left value) and the right one as the rvalue (right value). The lvalue has to be a variable whereas the rvalue can be either a constant, a variable, the result of an operation or any combination of these.\nThe most important rule when assigning is the right-to-left rule: The assignment operation always takes place from right to left, and never the other way:\n\n \na = b;\n\n\nThis statement assigns to variable a (the lvalue) the value contained in variable b (the rvalue). The value that was stored until this moment in a is not considered at all in this operation, and in fact that value is lost.\n\nConsider also that we are only assigning the value of b to a at the moment of the assignment operation. Therefore a later change of b will not affect the new value of a.\n\nFor example, let us have a look at the following code - I have included the evolution of the content stored in the variables as comments:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n// assignment operator\n\n#include <iostream>\nusing namespace std;\n\nint main ()\n{\n int a, b; // a:?, b:?\n a = 10; // a:10, b:?\n b = 4; // a:10, b:4\n a = b; // a:4, b:4\n b = 7; // a:4, b:7\n\n cout << \"a:\";\n cout << a;\n cout << \" b:\";\n cout << b;\n\n return 0;\n}\na:4 b:7\n\n\nThis code will give us as result that the value contained in a is 4 and the one contained in b is 7. Notice how a was not affected by the final modification of b, even though we declared a = b earlier (that is because of the right-to-left rule).\n\nA property that C++ has over other programming languages is that the assignment operation can be used as the rvalue (or part of an rvalue) for another assignment operation. For example: \n\n \na = 2 + (b = 5);\n\n\nis equivalent to: \n\n1\n2\nb = 5;\na = 2 + b;\n\n\nthat means: first assign 5 to variable b and then assign to a the value 2 plus the result of the previous assignment of b (i.e. 5), leaving a with a final value of 7.\n\nThe following expression is also valid in C++: \n\n \na = b = c = 5;\n\n\nIt assigns 5 to the all three variables: a, b and c. \n\nArithmetic operators ( +, -, *, /, % )\nThe five arithmetical operations supported by the C++ language are: \n\n+\taddition\n-\tsubtraction\n*\tmultiplication\n/\tdivision\n%\tmodulo\n\nOperations of addition, subtraction, multiplication and division literally correspond with their respective mathematical operators. The only one that you might not be so used to see is modulo; whose operator is the percentage sign (%). Modulo is the operation that gives the remainder of a division of two values. For example, if we write:\n\n \na = 11 % 3;\n\n\nthe variable a will contain the value 2, since 2 is the remainder from dividing 11 between 3.\n\nCompound assignment (+=, -=, *=, /=, %=, >>=, <<=, &=, ^=, |=)\n\nWhen we want to modify the value of a variable by performing an operation on the value currently stored in that variable we can use compound assignment operators:\n\nexpression\tis equivalent to\nvalue += increase;\tvalue = value + increase;\na -= 5;\ta = a - 5;\na /= b;\ta = a / b;\nprice *= units + 1;\tprice = price * (units + 1);\n\nand the same for all other operators. For example:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n// compound assignment operators\n\n#include <iostream>\nusing namespace std;\n\nint main ()\n{\n int a, b=3;\n a = b;\n a+=2; // equivalent to a=a+2\n cout << a;\n return 0;\n}\n5\n\n\nIncrease and decrease (++, --)\nShortening even more some expressions, the increase operator (++) and the decrease operator (--) increase or reduce by one the value stored in a variable. They are equivalent to +=1 and to -=1, respectively. Thus:\n\n1\n2\n3\n++c;\nc+=1;\nc=c+1;\n\n\nare all equivalent in its functionality: the three of them increase by one the value of c.\n\nIn the early C compilers, the three previous expressions probably produced different executable code depending on which one was used. Nowadays, this type of code optimization is generally done automatically by the compiler, thus the three expressions should produce exactly the same executable code.\n\nA characteristic of this operator is that it can be used both as a prefix and as a suffix. That means that it can be written either before the variable identifier (++a) or after it (a++). Although in simple expressions like a++ or ++a both have exactly the same meaning, in other expressions in which the result of the increase or decrease operation is evaluated as a value in an outer expression they may have an important difference in their meaning: In the case that the increase operator is used as a prefix (++a) the value is increased before the result of the expression is evaluated and therefore the increased value is considered in the outer expression; in case that it is used as a suffix (a++) the value stored in a is increased after being evaluated and therefore the value stored before the increase operation is evaluated in the outer expression. Notice the difference:\n\nExample 1\tExample 2\nB=3;\nA=++B;\n// A contains 4, B contains 4\tB=3;\nA=B++;\n// A contains 3, B contains 4\n\nIn Example 1, B is increased before its value is copied to A. While in Example 2, the value of B is copied to A and then B is increased. \n\nRelational and equality operators ( ==, !=, >, <, >=, <= )\n\nIn order to evaluate a comparison between two expressions we can use the relational and equality operators. The result of a relational operation is a Boolean value that can only be true or false, according to its Boolean result.\n\nWe may want to compare two expressions, for example, to know if they are equal or if one is greater than the other is. Here is a list of the relational and equality operators that can be used in C++: \n\n==\tEqual to\n!=\tNot equal to\n>\tGreater than\n<\tLess than\n>=\tGreater than or equal to\n<=\tLess than or equal to\n\nHere there are some examples:\n\n1\n2\n3\n4\n5\n(7 == 5) // evaluates to false.\n(5 > 4) // evaluates to true.\n(3 != 2) // evaluates to true.\n(6 >= 6) // evaluates to true.\n(5 < 5) // evaluates to false. \n\n\nOf course, instead of using only numeric constants, we can use any valid expression, including variables. Suppose that a=2, b=3 and c=6,\n\n1\n2\n3\n4\n(a == 5) // evaluates to false since a is not equal to 5.\n(a*b >= c) // evaluates to true since (2*3 >= 6) is true. \n(b+4 > a*c) // evaluates to false since (3+4 > 2*6) is false. \n((b=2) == a) // evaluates to true. \n\n\nBe careful! The operator = (one equal sign) is not the same as the operator == (two equal signs), the first one is an assignment operator (assigns the value at its right to the variable at its left) and the other one (==) is the equality operator that compares whether both expressions in the two sides of it are equal to each other. Thus, in the last expression ((b=2) == a), we first assigned the value 2 to b and then we compared it to a, that also stores the value 2, so the result of the operation is true.\n\nLogical operators ( !, &&, || )\n\nThe Operator ! is the C++ operator to perform the Boolean operation NOT, it has only one operand, located at its right, and the only thing that it does is to inverse the value of it, producing false if its operand is true and true if its operand is false. Basically, it returns the opposite Boolean value of evaluating its operand. For example:\n\n1\n2\n3\n4\n!(5 == 5) // evaluates to false because the expression at its right (5 == 5) is true. \n!(6 <= 4) // evaluates to true because (6 <= 4) would be false. \n!true // evaluates to false\n!false // evaluates to true. \n\n\nThe logical operators && and || are used when evaluating two expressions to obtain a single relational result. The operator && corresponds with Boolean logical operation AND. This operation results true if both its two operands are true, and false otherwise. The following panel shows the result of operator && evaluating the expression a && b:\n\n&& OPERATOR\na\tb\ta && b\ntrue\ttrue\ttrue\ntrue\tfalse\tfalse\nfalse\ttrue\tfalse\nfalse\tfalse\tfalse\n\nThe operator || corresponds with Boolean logical operation OR. This operation results true if either one of its two operands is true, thus being false only when both operands are false themselves. Here are the possible results of a || b:\n\n|| OPERATOR\na\tb\ta || b\ntrue\ttrue\ttrue\ntrue\tfalse\ttrue\nfalse\ttrue\ttrue\nfalse\tfalse\tfalse\n\nFor example:\n\n1\n2\n( (5 == 5) && (3 > 6) ) // evaluates to false ( true && false ).\n( (5 == 5) || (3 > 6) ) // evaluates to true ( true || false ). \n\n\nWhen using the logical operators, C++ only evaluates what is necessary from left to right to come up with the combined relational result, ignoring the rest. Therefore, in this last example ((5==5)||(3>6)), C++ would evaluate first whether 5==5 is true, and if so, it would never check whether 3>6 is true or not. This is known as short-circuit evaluation, and works like this for these operators:\n\noperator\tshort-circuit\n&&\tif the left-hand side expression is false, the combined result is false (right-hand side expression not evaluated).\n||\tif the left-hand side expression is true, the combined result is true (right-hand side expression not evaluated).\n\nThis is mostly important when the right-hand expression has side effects, such as altering values:\n\n \nif ((i<10)&&(++i<n)) { /*...*/ }\n\n\nThis combined conditional expression increases i by one, but only if the condition on the left of && is true, since otherwise the right-hand expression (++i<n) is never evaluated.\n\nConditional operator ( ? )\n\nThe conditional operator evaluates an expression returning a value if that expression is true and a different one if the expression is evaluated as false. Its format is: \n\ncondition ? result1 : result2\n\nIf condition is true the expression will return result1, if it is not it will return result2.\n\n1\n2\n3\n4\n7==5 ? 4 : 3 // returns 3, since 7 is not equal to 5.\n7==5+2 ? 4 : 3 // returns 4, since 7 is equal to 5+2.\n5>3 ? a : b // returns the value of a, since 5 is greater than 3.\na>b ? a : b // returns whichever is greater, a or b. \n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n// conditional operator\n\n#include <iostream>\nusing namespace std;\n\nint main ()\n{\n int a,b,c;\n\n a=2;\n b=7;\n c = (a>b) ? a : b;\n\n cout << c;\n\n return 0;\n}\n7\n\n\nIn this example a was 2 and b was 7, so the expression being evaluated (a>b) was not true, thus the first value specified after the question mark was discarded in favor of the second value (the one after the colon) which was b, with a value of 7.\n\nComma operator ( , )\nThe comma operator (,) is used to separate two or more expressions that are included where only one expression is expected. When the set of expressions has to be evaluated for a value, only the rightmost expression is considered.\n\nFor example, the following code:\n\n \na = (b=3, b+2);\n\n\nWould first assign the value 3 to b, and then assign b+2 to variable a. So, at the end, variable a would contain the value 5 while variable b would contain value 3.\n\nBitwise Operators ( &, |, ^, ~, <<, >> )\n\nBitwise operators modify variables considering the bit patterns that represent the values they store.\n\noperator\tasm equivalent\tdescription\n&\tAND\tBitwise AND\n|\tOR\tBitwise Inclusive OR\n^\tXOR\tBitwise Exclusive OR\n~\tNOT\tUnary complement (bit inversion)\n<<\tSHL\tShift Left\n>>\tSHR\tShift Right\n\nExplicit type casting operator\nType casting operators allow you to convert a datum of a given type to another. There are several ways to do this in C++. The simplest one, which has been inherited from the C language, is to precede the expression to be converted by the new type enclosed between parentheses (()):\n\n1\n2\n3\nint i;\nfloat f = 3.14;\ni = (int) f;\n\n\nThe previous code converts the float number 3.14 to an integer value (3), the remainder is lost. Here, the typecasting operator was (int). Another way to do the same thing in C++ is using the functional notation: preceding the expression to be converted by the type and enclosing the expression between parentheses:\n\n \ni = int ( f );\n\n\nBoth ways of type casting are valid in C++.\n\nsizeof()\nThis operator accepts one parameter, which can be either a type or a variable itself and returns the size in bytes of that type or object:\n\n \na = sizeof (char);\n\n\nThis will assign the value 1 to a because char is a one-byte long type.\nThe value returned by sizeof is a constant, so it is always determined before program execution.\n\nOther operators\nLater in these tutorials, we will see a few more operators, like the ones referring to pointers or the specifics for object-oriented programming. Each one is treated in its respective section.\n\nPrecedence of operators\nWhen writing complex expressions with several operands, we may have some doubts about which operand is evaluated first and which later. For example, in this expression:\n\n \na = 5 + 7 % 2\n\n\nwe may doubt if it really means:\n\n1\n2\na = 5 + (7 % 2) // with a result of 6, or\na = (5 + 7) % 2 // with a result of 0 \n\n\nThe correct answer is the first of the two expressions, with a result of 6. There is an established order with the priority of each operator, and not only the arithmetic ones (those whose preference come from mathematics) but for all the operators which can appear in C++. From greatest to lowest priority, the priority order is as follows: \n\nLevel\tOperator\tDescription\tGrouping\n1\t::\tscope\tLeft-to-right\n2\t() [] . -> ++ -- dynamic_cast static_cast reinterpret_cast const_cast typeid\tpostfix\tLeft-to-right\n3\t++ -- ~ ! sizeof new delete\tunary (prefix)\tRight-to-left\n* &\tindirection and reference (pointers)\n+ -\tunary sign operator\n4\t(type)\ttype casting\tRight-to-left\n5\t.* ->*\tpointer-to-member\tLeft-to-right\n6\t* / %\tmultiplicative\tLeft-to-right\n7\t+ -\tadditive\tLeft-to-right\n8\t<< >>\tshift\tLeft-to-right\n9\t< > <= >=\trelational\tLeft-to-right\n10\t== !=\tequality\tLeft-to-right\n11\t&\tbitwise AND\tLeft-to-right\n12\t^\tbitwise XOR\tLeft-to-right\n13\t|\tbitwise OR\tLeft-to-right\n14\t&&\tlogical AND\tLeft-to-right\n15\t||\tlogical OR\tLeft-to-right\n16\t?:\tconditional\tRight-to-left\n17\t= *= /= %= += -= >>= <<= &= ^= |=\tassignment\tRight-to-left\n18\t,\tcomma\tLeft-to-right\n\nGrouping defines the precedence order in which operators are evaluated in the case that there are several operators of the same level in an expression.\n\nAll these precedence levels for operators can be manipulated or become more legible by removing possible ambiguities using parentheses signs ( and ), as in this example:\n\n \na = 5 + 7 % 2;\n\n\nmight be written either as:\n\n \na = 5 + (7 % 2);\n\nor\n \na = (5 + 7) % 2;\n\n\ndepending on the operation that we want to perform.","A program is usually not limited to a linear sequence of instructions. During its process it may bifurcate, repeat code or take decisions. For that purpose, C++ provides control structures that serve to specify what has to be done by our program, when and under which circumstances.\n\nWith the introduction of control structures we are going to have to introduce a new concept: the compound-statement or block. A block is a group of statements which are separated by semicolons (;) like all C++ statements, but grouped together in a block enclosed in braces: { }:\n\n{ statement1; statement2; statement3; }\n\nMost of the control structures that we will see in this section require a generic statement as part of its syntax. A statement can be either a simple statement (a simple instruction ending with a semicolon) or a compound statement (several instructions grouped in a block), like the one just described. In the case that we want the statement to be a simple statement, we do not need to enclose it in braces ({}). But in the case that we want the statement to be a compound statement it must be enclosed between braces ({}), forming a block.\n\nConditional structure: if and else\nThe if keyword is used to execute a statement or block only if a condition is fulfilled. Its form is:\n\nif (condition) statement\n\nWhere condition is the expression that is being evaluated. If this condition is true, statement is executed. If it is false, statement is ignored (not executed) and the program continues right after this conditional structure.\nFor example, the following code fragment prints x is 100 only if the value stored in the x variable is indeed 100:\n\n1\n2\nif (x == 100)\n cout << \"x is 100\";\n\n\nIf we want more than a single statement to be executed in case that the condition is true we can specify a block using braces { }:\n\n1\n2\n3\n4\n5\nif (x == 100)\n{\n cout << \"x is \";\n cout << x;\n}\n\n\nWe can additionally specify what we want to happen if the condition is not fulfilled by using the keyword else. Its form used in conjunction with if is:\n\nif (condition) statement1 else statement2\n\nFor example:\n\n1\n2\n3\n4\nif (x == 100)\n cout << \"x is 100\";\nelse\n cout << \"x is not 100\";\n\n\nprints on the screen x is 100 if indeed x has a value of 100, but if it has not -and only if not- it prints out x is not 100.\n\nThe if + else structures can be concatenated with the intention of verifying a range of values. The following example shows its use telling if the value currently stored in x is positive, negative or none of them (i.e. zero):\n\n1\n2\n3\n4\n5\n6\nif (x > 0)\n cout << \"x is positive\";\nelse if (x < 0)\n cout << \"x is negative\";\nelse\n cout << \"x is 0\";\n\n\nRemember that in case that we want more than a single statement to be executed, we must group them in a block by enclosing them in braces { }.\n\nIteration structures (loops)\n\nLoops have as purpose to repeat a statement a certain number of times or while a condition is fulfilled.\n\nThe while loop\nIts format is:\n\nwhile (expression) statement\n\nand its functionality is simply to repeat statement while the condition set in expression is true.\nFor example, we are going to make a program to countdown using a while-loop:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n// custom countdown using while\n\n#include <iostream>\nusing namespace std;\n\nint main ()\n{\n int n;\n cout << \"Enter the starting number > \";\n cin >> n;\n\n while (n>0) {\n cout << n << \", \";\n --n;\n }\n\n cout << \"FIRE!\\n\";\n return 0;\n}\nEnter the starting number > 8\n8, 7, 6, 5, 4, 3, 2, 1, FIRE!\n\n\nWhen the program starts the user is prompted to insert a starting number for the countdown. Then the while loop begins, if the value entered by the user fulfills the condition n>0 (that n is greater than zero) the block that follows the condition will be executed and repeated while the condition (n>0) remains being true.\n\nThe whole process of the previous program can be interpreted according to the following script (beginning in main):\n\nUser assigns a value to n\nThe while condition is checked (n>0). At this point there are two possibilities:\n* condition is true: statement is executed (to step 3)\n* condition is false: ignore statement and continue after it (to step 5)\nExecute statement:\ncout << n << \", \";\n--n;\n(prints the value of n on the screen and decreases n by 1)\nEnd of block. Return automatically to step 2\nContinue the program right after the block: print FIRE! and end program.\n\nWhen creating a while-loop, we must always consider that it has to end at some point, therefore we must provide within the block some method to force the condition to become false at some point, otherwise the loop will continue looping forever. In this case we have included --n; that decreases the value of the variable that is being evaluated in the condition (n) by one - this will eventually make the condition (n>0) to become false after a certain number of loop iterations: to be more specific, when n becomes 0, that is where our while-loop and our countdown end.\n\nOf course this is such a simple action for our computer that the whole countdown is performed instantly without any practical delay between numbers.\n\nThe do-while loop\n\nIts format is:\n\ndo statement while (condition);\n\nIts functionality is exactly the same as the while loop, except that condition in the do-while loop is evaluated after the execution of statement instead of before, granting at least one execution of statement even if condition is never fulfilled. For example, the following example program echoes any number you enter until you enter 0.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n// number echoer\n\n#include <iostream>\nusing namespace std;\n\nint main ()\n{\n unsigned long n;\n do {\n cout << \"Enter number (0 to end): \";\n cin >> n;\n cout << \"You entered: \" << n << \"\\n\";\n } while (n != 0);\n return 0;\n}\nEnter number (0 to end): 12345\nYou entered: 12345\nEnter number (0 to end): 160277\nYou entered: 160277\nEnter number (0 to end): 0\nYou entered: 0\n\n\nThe do-while loop is usually used when the condition that has to determine the end of the loop is determined within the loop statement itself, like in the previous case, where the user input within the block is what is used to determine if the loop has to end. In fact if you never enter the value 0 in the previous example you can be prompted for more numbers forever.\n\nThe for loop\n\nIts format is:\n\nfor (initialization; condition; increase) statement;\n\nand its main function is to repeat statement while condition remains true, like the while loop. But in addition, the for loop provides specific locations to contain an initialization statement and an increase statement. So this loop is specially designed to perform a repetitive action with a counter which is initialized and increased on each iteration.\n\nIt works in the following way:\n\ninitialization is executed. Generally it is an initial value setting for a counter variable. This is executed only once.\ncondition is checked. If it is true the loop continues, otherwise the loop ends and statement is skipped (not executed).\nstatement is executed. As usual, it can be either a single statement or a block enclosed in braces { }.\nfinally, whatever is specified in the increase field is executed and the loop gets back to step 2.\n\nHere is an example of countdown using a for loop:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n// countdown using a for loop\n#include <iostream>\nusing namespace std;\nint main ()\n{\n for (int n=10; n>0; n--) {\n cout << n << \", \";\n }\n cout << \"FIRE!\\n\";\n return 0;\n}\n10, 9, 8, 7, 6, 5, 4, 3, 2, 1, FIRE!\n\n\nThe initialization and increase fields are optional. They can remain empty, but in all cases the semicolon signs between them must be written. For example we could write: for (;n<10;) if we wanted to specify no initialization and no increase; or for (;n<10;n++) if we wanted to include an increase field but no initialization (maybe because the variable was already initialized before).\n\nOptionally, using the comma operator (,) we can specify more than one expression in any of the fields included in a for loop, like in initialization, for example. The comma operator (,) is an expression separator, it serves to separate more than one expression where only one is generally expected. For example, suppose that we wanted to initialize more than one variable in our loop:\n\n1\n2\n3\n4\nfor ( n=0, i=100 ; n!=i ; n++, i-- )\n{\n // whatever here...\n}\n\n\nThis loop will execute for 50 times if neither n or i are modified within the loop:\n\n \nn starts with a value of 0, and i with 100, the condition is n!=i (that n is not equal to i). Because n is increased by one and i decreased by one, the loop\'s condition will become false after the 50th loop, when both n and i will be equal to 50.\n\nJump statements.\n\nThe break statement\n\nUsing break we can leave a loop even if the condition for its end is not fulfilled. It can be used to end an infinite loop, or to force it to end before its natural end. For example, we are going to stop the count down before its natural end (maybe because of an engine check failure?):\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n// break loop example\n\n#include <iostream>\nusing namespace std;\n\nint main ()\n{\n int n;\n for (n=10; n>0; n--)\n {\n cout << n << \", \";\n if (n==3)\n {\n cout << \"countdown aborted!\";\n break;\n }\n }\n return 0;\n}\n10, 9, 8, 7, 6, 5, 4, 3, countdown aborted!\n\n\nThe continue statement\n\nThe continue statement causes the program to skip the rest of the loop in the current iteration as if the end of the statement block had been reached, causing it to jump to the start of the following iteration. For example, we are going to skip the number 5 in our countdown:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n// continue loop example\n#include <iostream>\nusing namespace std;\n\nint main ()\n{\n for (int n=10; n>0; n--) {\n if (n==5) continue;\n cout << n << \", \";\n }\n cout << \"FIRE!\\n\";\n return 0;\n}\n10, 9, 8, 7, 6, 4, 3, 2, 1, FIRE!\n\n\nThe goto statement\ngoto allows to make an absolute jump to another point in the program. You should use this feature with caution since its execution causes an unconditional jump ignoring any type of nesting limitations.\nThe destination point is identified by a label, which is then used as an argument for the goto statement. A label is made of a valid identifier followed by a colon (:).\n\nGenerally speaking, this instruction has no concrete use in structured or object oriented programming aside from those that low-level programming fans may find for it. For example, here is our countdown loop using goto:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n// goto loop example\n\n#include <iostream>\nusing namespace std;\n\nint main ()\n{\n int n=10;\n loop:\n cout << n << \", \";\n n--;\n if (n>0) goto loop;\n cout << \"FIRE!\\n\";\n return 0;\n}\n10, 9, 8, 7, 6, 5, 4, 3, 2, 1, FIRE!\n\n\nThe exit function\n\nexit is a function defined in the cstdlib library.\n\nThe purpose of exit is to terminate the current program with a specific exit code. Its prototype is:\n\n \nvoid exit (int exitcode);\n\n\nThe exitcode is used by some operating systems and may be used by calling programs. By convention, an exit code of 0 means that the program finished normally and any other value means that some error or unexpected results happened.\n\nThe selective structure: switch.\nThe syntax of the switch statement is a bit peculiar. Its objective is to check several possible constant values for an expression. Something similar to what we did at the beginning of this section with the concatenation of several if and else if instructions. Its form is the following:\n\nswitch (expression)\n{\n case constant1:\n group of statements 1;\n break;\n case constant2:\n group of statements 2;\n break;\n .\n .\n .\n default:\n default group of statements\n}\n\nIt works in the following way: switch evaluates expression and checks if it is equivalent to constant1, if it is, it executes group of statements 1 until it finds the break statement. When it finds this break statement the program jumps to the end of the switch selective structure.\n\nIf expression was not equal to constant1 it will be checked against constant2. If it is equal to this, it will execute group of statements 2 until a break keyword is found, and then will jump to the end of the switch selective structure.\n\nFinally, if the value of expression did not match any of the previously specified constants (you can include as many case labels as values you want to check), the program will execute the statements included after the default: label, if it exists (since it is optional).\n\nBoth of the following code fragments have the same behavior:\n\nswitch example\tif-else equivalent\nswitch (x) {\n case 1:\n cout << \"x is 1\";\n break;\n case 2:\n cout << \"x is 2\";\n break;\n default:\n cout << \"value of x unknown\";\n }\nif (x == 1) {\n cout << \"x is 1\";\n }\nelse if (x == 2) {\n cout << \"x is 2\";\n }\nelse {\n cout << \"value of x unknown\";\n }\n\nThe switch statement is a bit peculiar within the C++ language because it uses labels instead of blocks. This forces us to put break statements after the group of statements that we want to be executed for a specific condition. Otherwise the remainder statements -including those corresponding to other labels- will also be executed until the end of the switch selective block or a break statement is reached.\n\nFor example, if we did not include a break statement after the first group for case one, the program will not automatically jump to the end of the switch selective block and it would continue executing the rest of statements until it reaches either a break instruction or the end of the switch selective block. This makes it unnecessary to include braces { } surrounding the statements for each of the cases, and it can also be useful to execute the same block of instructions for different possible values for the expression being evaluated. For example: \n\n1\n2\n3\n4\n5\n6\n7\n8\n9\nswitch (x) {\n case 1:\n case 2:\n case 3:\n cout << \"x is 1, 2 or 3\";\n break;\n default:\n cout << \"x is not 1, 2 nor 3\";\n }","An array is a series of elements of the same type placed in contiguous memory locations that can be individually referenced by adding an index to a unique identifier.\n\nThat means that, for example, we can store 5 values of type int in an array without having to declare 5 different variables, each one with a different identifier. Instead of that, using an array we can store 5 different values of the same type, int for example, with a unique identifier.\n\nFor example, an array to contain 5 integer values of type int called billy could be represented like this:\n\n \nwhere each blank panel represents an element of the array, that in this case are integer values of type int. These elements are numbered from 0 to 4 since in arrays the first index is always 0, independently of its length.\n\nLike a regular variable, an array must be declared before it is used. A typical declaration for an array in C++ is:\n\ntype name [elements];\n\nwhere type is a valid type (like int, float...), name is a valid identifier and the elements field (which is always enclosed in square brackets []), specifies how many of these elements the array has to contain.\n\nTherefore, in order to declare an array called billy as the one shown in the above diagram it is as simple as:\n\n \nint billy [5];\n\n\nNOTE: The elements field within brackets [] which represents the number of elements the array is going to hold, must be a constant value, since arrays are blocks of non-dynamic memory whose size must be determined before execution. In order to create arrays with a variable length dynamic memory is needed, which is explained later in these tutorials.\n\nInitializing arrays.\nWhen declaring a regular array of local scope (within a function, for example), if we do not specify otherwise, its elements will not be initialized to any value by default, so their content will be undetermined until we store some value in them. The elements of global and static arrays, on the other hand, are automatically initialized with their default values, which for all fundamental types this means they are filled with zeros.\n\nIn both cases, local and global, when we declare an array, we have the possibility to assign initial values to each one of its elements by enclosing the values in braces { }. For example:\n\n \nint billy [5] = { 16, 2, 77, 40, 12071 }; \n\n\nThis declaration would have created an array like this:\n\n \nThe amount of values between braces { } must not be larger than the number of elements that we declare for the array between square brackets [ ]. For example, in the example of array billy we have declared that it has 5 elements and in the list of initial values within braces { } we have specified 5 values, one for each element.\n\nWhen an initialization of values is provided for an array, C++ allows the possibility of leaving the square brackets empty [ ]. In this case, the compiler will assume a size for the array that matches the number of values included between braces { }:\n\n \nint billy [] = { 16, 2, 77, 40, 12071 };\n\n\nAfter this declaration, array billy would be 5 ints long, since we have provided 5 initialization values.\n\nAccessing the values of an array.\n\nIn any point of a program in which an array is visible, we can access the value of any of its elements individually as if it was a normal variable, thus being able to both read and modify its value. The format is as simple as:\n\nname[index]\n\nFollowing the previous examples in which billy had 5 elements and each of those elements was of type int, the name which we can use to refer to each element is the following:\n\n \nFor example, to store the value 75 in the third element of billy, we could write the following statement:\n\n \nbilly[2] = 75;\n\n\nand, for example, to pass the value of the third element of billy to a variable called a, we could write:\n\n \na = billy[2];\n\n\nTherefore, the expression billy[2] is for all purposes like a variable of type int.\n\nNotice that the third element of billy is specified billy[2], since the first one is billy[0], the second one is billy[1], and therefore, the third one is billy[2]. By this same reason, its last element is billy[4]. Therefore, if we write billy[5], we would be accessing the sixth element of billy and therefore exceeding the size of the array.\n\nIn C++ it is syntactically correct to exceed the valid range of indices for an array. This can create problems, since accessing out-of-range elements do not cause compilation errors but can cause runtime errors. The reason why this is allowed will be seen further ahead when we begin to use pointers.\n\nAt this point it is important to be able to clearly distinguish between the two uses that brackets [ ] have related to arrays. They perform two different tasks: one is to specify the size of arrays when they are declared; and the second one is to specify indices for concrete array elements. Do not confuse these two possible uses of brackets [ ] with arrays.\n\n1\n2\nint billy[5]; // declaration of a new array\nbilly[2] = 75; // access to an element of the array. \n\n\nIf you read carefully, you will see that a type specifier always precedes a variable or array declaration, while it never precedes an access.\n\nSome other valid operations with arrays:\n\n1\n2\n3\n4\nbilly[0] = a;\nbilly[a] = 75;\nb = billy [a+2];\nbilly[billy[a]] = billy[2] + 5;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n// arrays example\n#include <iostream>\nusing namespace std;\n\nint billy [] = {16, 2, 77, 40, 12071};\nint n, result=0;\n\nint main ()\n{\n for ( n=0 ; n<5 ; n++ )\n {\n result += billy[n];\n }\n cout << result;\n return 0;\n}\n12206\n\n\nMultidimensional arrays\n\nMultidimensional arrays can be described as \"arrays of arrays\". For example, a bidimensional array can be imagined as a bidimensional table made of elements, all of them of a same uniform data type.\n\n \njimmy represents a bidimensional array of 3 per 5 elements of type int. The way to declare this array in C++ would be:\n\n \nint jimmy [3][5];\n\n\nand, for example, the way to reference the second element vertically and fourth horizontally in an expression would be: \n\n \njimmy[1][3]\n\n\n \n(remember that array indices always begin by zero).\n\nMultidimensional arrays are not limited to two indices (i.e., two dimensions). They can contain as many indices as needed. But be careful! The amount of memory needed for an array rapidly increases with each dimension. For example:\n\n \nchar century [100][365][24][60][60];\n\n\ndeclares an array with a char element for each second in a century, that is more than 3 billion chars. So this declaration would consume more than 3 gigabytes of memory!\n\nMultidimensional arrays are just an abstraction for programmers, since we can obtain the same results with a simple array just by putting a factor between its indices:\n\n1\n2\nint jimmy [3][5]; // is equivalent to\nint jimmy [15]; // (3 * 5 = 15) \n\n\nWith the only difference that with multidimensional arrays the compiler remembers the depth of each imaginary dimension for us. Take as example these two pieces of code, with both exactly the same result. One uses a bidimensional array and the other one uses a simple array: \n\nmultidimensional array\tpseudo-multidimensional array\n#define WIDTH 5\n#define HEIGHT 3\n\nint jimmy [HEIGHT][WIDTH];\nint n,m;\n\nint main ()\n{\n for (n=0;n<HEIGHT;n++)\n for (m=0;m<WIDTH;m++)\n {\n jimmy[n][m]=(n+1)*(m+1);\n }\n return 0;\n}\n#define WIDTH 5\n#define HEIGHT 3\n\nint jimmy [HEIGHT * WIDTH];\nint n,m;\n\nint main ()\n{\n for (n=0;n<HEIGHT;n++)\n for (m=0;m<WIDTH;m++)\n {\n jimmy[n*WIDTH+m]=(n+1)*(m+1);\n }\n return 0;\n}\n\nNone of the two source codes above produce any output on the screen, but both assign values to the memory block called jimmy in the following way: \n\n \nWe have used \"defined constants\" (#define) to simplify possible future modifications of the program. For example, in case that we decided to enlarge the array to a height of 4 instead of 3 it could be done simply by changing the line:\n\n \n#define HEIGHT 3 \n\nto:\n \n#define HEIGHT 4 \n\n\nwith no need to make any other modifications to the program. \n\nArrays as parameters\nAt some moment we may need to pass an array to a function as a parameter. In C++ it is not possible to pass a complete block of memory by value as a parameter to a function, but we are allowed to pass its address. In practice this has almost the same effect and it is a much faster and more efficient operation.\n\nIn order to accept arrays as parameters the only thing that we have to do when declaring the function is to specify in its parameters the element type of the array, an identifier and a pair of void brackets []. For example, the following function: \n\n \nvoid procedure (int arg[])\n\n\naccepts a parameter of type \"array of int\" called arg. In order to pass to this function an array declared as:\n\n \nint myarray [40];\n\n\nit would be enough to write a call like this:\n\n \nprocedure (myarray);\n\n\nHere you have a complete example: \n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n// arrays as parameters\n#include <iostream>\nusing namespace std;\n\nvoid printarray (int arg[], int length) {\n for (int n=0; n<length; n++)\n cout << arg[n] << \" \";\n cout << \"\\n\";\n}\n\nint main ()\n{\n int firstarray[] = {5, 10, 15};\n int secondarray[] = {2, 4, 6, 8, 10};\n printarray (firstarray,3);\n printarray (secondarray,5);\n return 0;\n}\n5 10 15\n2 4 6 8 10\n\n\nAs you can see, the first parameter (int arg[]) accepts any array whose elements are of type int, whatever its length. For that reason we have included a second parameter that tells the function the length of each array that we pass to it as its first parameter. This allows the for loop that prints out the array to know the range to iterate in the passed array without going out of range.\n\nIn a function declaration it is also possible to include multidimensional arrays. The format for a tridimensional array parameter is:\n\n \nbase_type[][depth][depth]\n\n\nfor example, a function with a multidimensional array as argument could be: \n\n \nvoid procedure (int myarray[][3][4])\n\n\nNotice that the first brackets [] are left empty while the following ones specify sizes for their respective dimensions. This is necessary in order for the compiler to be able to determine the depth of each additional dimension.\n\nArrays, both simple or multidimensional, passed as function parameters are a quite common source of errors for novice programmers. I recommend the reading of the chapter about Pointers for a better understanding on how arrays operate.","We have already seen how variables are seen as memory cells that can be accessed using their identifiers. This way we did not have to care about the physical location of our data within memory, we simply used its identifier whenever we wanted to refer to our variable.\n\nThe memory of your computer can be imagined as a succession of memory cells, each one of the minimal size that computers manage (one byte). These single-byte memory cells are numbered in a consecutive way, so as, within any block of memory, every cell has the same number as the previous one plus one.\n\nThis way, each cell can be easily located in the memory because it has a unique address and all the memory cells follow a successive pattern. For example, if we are looking for cell 1776 we know that it is going to be right between cells 1775 and 1777, exactly one thousand cells after 776 and exactly one thousand cells before cell 2776.\n\nReference operator (&)\nAs soon as we declare a variable, the amount of memory needed is assigned for it at a specific location in memory (its memory address). We generally do not actively decide the exact location of the variable within the panel of cells that we have imagined the memory to be - Fortunately, that is a task automatically performed by the operating system during runtime. However, in some cases we may be interested in knowing the address where our variable is being stored during runtime in order to operate with relative positions to it.\n\nThe address that locates a variable within memory is what we call a reference to that variable. This reference to a variable can be obtained by preceding the identifier of a variable with an ampersand sign (&), known as reference operator, and which can be literally translated as \"address of\". For example: \n\n \nted = &andy;\n\n\nThis would assign to ted the address of variable andy, since when preceding the name of the variable andy with the reference operator (&) we are no longer talking about the content of the variable itself, but about its reference (i.e., its address in memory).\n\nFrom now on we are going to assume that andy is placed during runtime in the memory address 1776. This number (1776) is just an arbitrary assumption we are inventing right now in order to help clarify some concepts in this tutorial, but in reality, we cannot know before runtime the real value the address of a variable will have in memory.\n\nConsider the following code fragment:\n\n1\n2\n3\nandy = 25;\nfred = andy;\nted = &andy; \n\n\nThe values contained in each variable after the execution of this, are shown in the following diagram: \n\n \nFirst, we have assigned the value 25 to andy (a variable whose address in memory we have assumed to be 1776).\n\nThe second statement copied to fred the content of variable andy (which is 25). This is a standard assignment operation, as we have done so many times before.\n\nFinally, the third statement copies to ted not the value contained in andy but a reference to it (i.e., its address, which we have assumed to be 1776). The reason is that in this third assignment operation we have preceded the identifier andy with the reference operator (&), so we were no longer referring to the value of andy but to its reference (its address in memory).\n\nThe variable that stores the reference to another variable (like ted in the previous example) is what we call a pointer. Pointers are a very powerful feature of the C++ language that has many uses in advanced programming. Farther ahead, we will see how this type of variable is used and declared.\n\nDereference operator (*)\n\nWe have just seen that a variable which stores a reference to another variable is called a pointer. Pointers are said to \"point to\" the variable whose reference they store.\n\nUsing a pointer we can directly access the value stored in the variable which it points to. To do this, we simply have to precede the pointer\'s identifier with an asterisk (*), which acts as dereference operator and that can be literally translated to \"value pointed by\".\n\nTherefore, following with the values of the previous example, if we write: \n\n \nbeth = *ted;\n\n\n(that we could read as: \"beth equal to value pointed by ted\") beth would take the value 25, since ted is 1776, and the value pointed by 1776 is 25.\n\n \nYou must clearly differentiate that the expression ted refers to the value 1776, while *ted (with an asterisk * preceding the identifier) refers to the value stored at address 1776, which in this case is 25. Notice the difference of including or not including the dereference operator (I have included an explanatory commentary of how each of these two expressions could be read): \n\n1\n2\nbeth = ted; // beth equal to ted ( 1776 )\nbeth = *ted; // beth equal to value pointed by ted ( 25 ) \n\n\nNotice the difference between the reference and dereference operators:\n& is the reference operator and can be read as \"address of\"\n* is the dereference operator and can be read as \"value pointed by\"\nThus, they have complementary (or opposite) meanings. A variable referenced with & can be dereferenced with *.\n\nEarlier we performed the following two assignment operations:\n\n1\n2\nandy = 25;\nted = &andy;\n\n\nRight after these two statements, all of the following expressions would give true as result:\n\n1\n2\n3\n4\nandy == 25\n&andy == 1776\nted == 1776\n*ted == 25\n\n\nThe first expression is quite clear considering that the assignment operation performed on andy was andy=25. The second one uses the reference operator (&), which returns the address of variable andy, which we assumed it to have a value of 1776. The third one is somewhat obvious since the second expression was true and the assignment operation performed on ted was ted=&andy. The fourth expression uses the dereference operator (*) that, as we have just seen, can be read as \"value pointed by\", and the value pointed by ted is indeed 25.\n\nSo, after all that, you may also infer that for as long as the address pointed by ted remains unchanged the following expression will also be true: \n\n \n*ted == andy\n\n\nDeclaring variables of pointer types\nDue to the ability of a pointer to directly refer to the value that it points to, it becomes necessary to specify in its declaration which data type a pointer is going to point to. It is not the same thing to point to a char as to point to an int or a float.\n\nThe declaration of pointers follows this format:\n\ntype * name; \n\nwhere type is the data type of the value that the pointer is intended to point to. This type is not the type of the pointer itself! but the type of the data the pointer points to. For example:\n\n1\n2\n3\nint * number;\nchar * character;\nfloat * greatnumber;\n\n\nThese are three declarations of pointers. Each one is intended to point to a different data type, but in fact all of them are pointers and all of them will occupy the same amount of space in memory (the size in memory of a pointer depends on the platform where the code is going to run). Nevertheless, the data to which they point to do not occupy the same amount of space nor are of the same type: the first one points to an int, the second one to a char and the last one to a float. Therefore, although these three example variables are all of them pointers which occupy the same size in memory, they are said to have different types: int*, char* and float* respectively, depending on the type they point to.\n\nI want to emphasize that the asterisk sign (*) that we use when declaring a pointer only means that it is a pointer (it is part of its type compound specifier), and should not be confused with the dereference operator that we have seen a bit earlier, but which is also written with an asterisk (*). They are simply two different things represented with the same sign.\n\nNow have a look at this code:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n// my first pointer\n#include <iostream>\nusing namespace std;\n\nint main ()\n{\n int firstvalue, secondvalue;\n int * mypointer;\n\n mypointer = &firstvalue;\n *mypointer = 10;\n mypointer = &secondvalue;\n *mypointer = 20;\n cout << \"firstvalue is \" << firstvalue << endl;\n cout << \"secondvalue is \" << secondvalue << endl;\n return 0;\n}\nfirstvalue is 10\nsecondvalue is 20\n\n\nNotice that even though we have never directly set a value to either firstvalue or secondvalue, both end up with a value set indirectly through the use of mypointer. This is the procedure:\n\nFirst, we have assigned as value of mypointer a reference to firstvalue using the reference operator (&). And then we have assigned the value 10 to the memory location pointed by mypointer, that because at this moment is pointing to the memory location of firstvalue, this in fact modifies the value of firstvalue.\n\nIn order to demonstrate that a pointer may take several different values during the same program I have repeated the process with secondvalue and that same pointer, mypointer.\n\nHere is an example a little bit more elaborated:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n// more pointers\n#include <iostream>\nusing namespace std;\n\nint main ()\n{\n int firstvalue = 5, secondvalue = 15;\n int * p1, * p2;\n\n p1 = &firstvalue; // p1 = address of firstvalue\n p2 = &secondvalue; // p2 = address of secondvalue\n *p1 = 10; // value pointed by p1 = 10\n *p2 = *p1; // value pointed by p2 = value pointed by p1\n p1 = p2; // p1 = p2 (value of pointer is copied)\n *p1 = 20; // value pointed by p1 = 20\n \n cout << \"firstvalue is \" << firstvalue << endl;\n cout << \"secondvalue is \" << secondvalue << endl;\n return 0;\n}\nfirstvalue is 10\nsecondvalue is 20\n\n\nI have included as a comment on each line how the code can be read: ampersand (&) as \"address of\" and asterisk (*) as \"value pointed by\".\n\nNotice that there are expressions with pointers p1 and p2, both with and without dereference operator (*). The meaning of an expression using the dereference operator (*) is very different from one that does not: When this operator precedes the pointer name, the expression refers to the value being pointed, while when a pointer name appears without this operator, it refers to the value of the pointer itself (i.e. the address of what the pointer is pointing to).\n\nAnother thing that may call your attention is the line: \n\n \nint * p1, * p2;\n\n\nThis declares the two pointers used in the previous example. But notice that there is an asterisk (*) for each pointer, in order for both to have type int* (pointer to int).\n\nOtherwise, the type for the second variable declared in that line would have been int (and not int*) because of precedence relationships. If we had written:\n\n \nint * p1, p2;\n\n\np1 would indeed have int* type, but p2 would have type int (spaces do not matter at all for this purpose). This is due to operator precedence rules. But anyway, simply remembering that you have to put one asterisk per pointer is enough for most pointer users.\n\nPointers and arrays\nThe concept of array is very much bound to the one of pointer. In fact, the identifier of an array is equivalent to the address of its first element, as a pointer is equivalent to the address of the first element that it points to, so in fact they are the same concept. For example, supposing these two declarations:\n\n1\n2\nint numbers [20];\nint * p;\n\n\nThe following assignment operation would be valid: \n\n \np = numbers; \n\n\nAfter that, p and numbers would be equivalent and would have the same properties. The only difference is that we could change the value of pointer p by another one, whereas numbers will always point to the first of the 20 elements of type int with which it was defined. Therefore, unlike p, which is an ordinary pointer, numbers is an array, and an array can be considered a constant pointer. Therefore, the following allocation would not be valid:\n\n \nnumbers = p;\n\n\nBecause numbers is an array, so it operates as a constant pointer, and we cannot assign values to constants.\n\nDue to the characteristics of variables, all expressions that include pointers in the following example are perfectly valid:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n// more pointers\n#include <iostream>\nusing namespace std;\n\nint main ()\n{\n int numbers[5];\n int * p;\n p = numbers; *p = 10;\n p++; *p = 20;\n p = &numbers[2]; *p = 30;\n p = numbers + 3; *p = 40;\n p = numbers; *(p+4) = 50;\n for (int n=0; n<5; n++)\n cout << numbers[n] << \", \";\n return 0;\n}\n10, 20, 30, 40, 50, \n\n\nIn the chapter about arrays we used brackets ([]) several times in order to specify the index of an element of the array to which we wanted to refer. Well, these bracket sign operators [] are also a dereference operator known as offset operator. They dereference the variable they follow just as * does, but they also add the number between brackets to the address being dereferenced. For example:\n\n1\n2\na[5] = 0; // a [offset of 5] = 0\n*(a+5) = 0; // pointed by (a+5) = 0 \n\n\nThese two expressions are equivalent and valid both if a is a pointer or if a is an array.\n\nPointer initialization\nWhen declaring pointers we may want to explicitly specify which variable we want them to point to:\n\n1\n2\nint number;\nint *tommy = &number;\n\n\nThe behavior of this code is equivalent to:\n\n1\n2\n3\nint number;\nint *tommy;\ntommy = &number;\n\n\nWhen a pointer initialization takes place we are always assigning the reference value to where the pointer points (tommy), never the value being pointed (*tommy). You must consider that at the moment of declaring a pointer, the asterisk (*) indicates only that it is a pointer, it is not the dereference operator (although both use the same sign: *). Remember, they are two different functions of one sign. Thus, we must take care not to confuse the previous code with: \n\n1\n2\n3\nint number;\nint *tommy;\n*tommy = &number;\n\n\nthat is incorrect, and anyway would not have much sense in this case if you think about it.\n\nAs in the case of arrays, the compiler allows the special case that we want to initialize the content at which the pointer points with constants at the same moment the pointer is declared:\n\n \nconst char * terry = \"hello\"; \n\n\nIn this case, memory space is reserved to contain \"hello\" and then a pointer to the first character of this memory block is assigned to terry. If we imagine that \"hello\" is stored at the memory locations that start at addresses 1702, we can represent the previous declaration as:\n\n \nIt is important to indicate that terry contains the value 1702, and not \'h\' nor \"hello\", although 1702 indeed is the address of both of these.\n\nThe pointer terry points to a sequence of characters and can be read as if it was an array (remember that an array is just like a constant pointer). For example, we can access the fifth element of the array with any of these two expression:\n\n1\n2\n*(terry+4)\nterry[4]\n\n\nBoth expressions have a value of \'o\' (the fifth element of the array).\n\nPointer arithmetics\n\nTo conduct arithmetical operations on pointers is a little different than to conduct them on regular integer data types. To begin with, only addition and subtraction operations are allowed to be conducted with them, the others make no sense in the world of pointers. But both addition and subtraction have a different behavior with pointers according to the size of the data type to which they point.\n\nWhen we saw the different fundamental data types, we saw that some occupy more or less space than others in the memory. For example, let\'s assume that in a given compiler for a specific machine, char takes 1 byte, short takes 2 bytes and long takes 4.\n\nSuppose that we define three pointers in this compiler: \n\n1\n2\n3\nchar *mychar;\nshort *myshort;\nlong *mylong;\n\n\nand that we know that they point to memory locations 1000, 2000 and 3000 respectively. \n\nSo if we write: \n\n1\n2\n3\nmychar++;\nmyshort++;\nmylong++;\n\n\nmychar, as you may expect, would contain the value 1001. But not so obviously, myshort would contain the value 2002, and mylong would contain 3004, even though they have each been increased only once. The reason is that when adding one to a pointer we are making it to point to the following element of the same type with which it has been defined, and therefore the size in bytes of the type pointed is added to the pointer.\n\n \nThis is applicable both when adding and subtracting any number to a pointer. It would happen exactly the same if we write: \n\n1\n2\n3\nmychar = mychar + 1;\nmyshort = myshort + 1;\nmylong = mylong + 1;\n\n\nBoth the increase (++) and decrease (--) operators have greater operator precedence than the dereference operator (*), but both have a special behavior when used as suffix (the expression is evaluated with the value it had before being increased). Therefore, the following expression may lead to confusion: \n\n \n*p++\n\n\nBecause ++ has greater precedence than *, this expression is equivalent to *(p++). Therefore, what it does is to increase the value of p (so it now points to the next element), but because ++ is used as postfix the whole expression is evaluated as the value pointed by the original reference (the address the pointer pointed to before being increased).\n\nNotice the difference with:\n\n(*p)++ \nHere, the expression would have been evaluated as the value pointed by p increased by one. The value of p (the pointer itself) would not be modified (what is being modified is what it is being pointed to by this pointer).\n\nIf we write:\n\n \n*p++ = *q++; \n\n\nBecause ++ has a higher precedence than *, both p and q are increased, but because both increase operators (++) are used as postfix and not prefix, the value assigned to *p is *q before both p and q are increased. And then both are increased. It would be roughly equivalent to:\n\n1\n2\n3\n*p = *q;\n++p;\n++q;\n\n\nLike always, I recommend you to use parentheses () in order to avoid unexpected results and to give more legibility to the code.\n\nPointers to pointers\nC++ allows the use of pointers that point to pointers, that these, in its turn, point to data (or even to other pointers). In order to do that, we only need to add an asterisk (*) for each level of reference in their declarations:\n\n1\n2\n3\n4\n5\n6\nchar a;\nchar * b;\nchar ** c;\na = \'z\';\nb = &a;\nc = &b;\n\n\nThis, supposing the randomly chosen memory locations for each variable of 7230, 8092 and 10502, could be represented as:\n\n \nThe value of each variable is written inside each cell; under the cells are their respective addresses in memory.\n\nThe new thing in this example is variable c, which can be used in three different levels of indirection, each one of them would correspond to a different value:\n\nc has type char** and a value of 8092\n*c has type char* and a value of 7230\n**c has type char and a value of \'z\'\n\nvoid pointers\nThe void type of pointer is a special type of pointer. In C++, void represents the absence of type, so void pointers are pointers that point to a value that has no type (and thus also an undetermined length and undetermined dereference properties).\n\nThis allows void pointers to point to any data type, from an integer value or a float to a string of characters. But in exchange they have a great limitation: the data pointed by them cannot be directly dereferenced (which is logical, since we have no type to dereference to), and for that reason we will always have to cast the address in the void pointer to some other pointer type that points to a concrete data type before dereferencing it.\n\nOne of its uses may be to pass generic parameters to a function: \n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n// increaser\n#include <iostream>\nusing namespace std;\n\nvoid increase (void* data, int psize)\n{\n if ( psize == sizeof(char) )\n { char* pchar; pchar=(char*)data; ++(*pchar); }\n else if (psize == sizeof(int) )\n { int* pint; pint=(int*)data; ++(*pint); }\n}\n\nint main ()\n{\n char a = \'x\';\n int b = 1602;\n increase (&a,sizeof(a));\n increase (&b,sizeof(b));\n cout << a << \", \" << b << endl;\n return 0;\n}\ny, 1603\n\n\nsizeof is an operator integrated in the C++ language that returns the size in bytes of its parameter. For non-dynamic data types this value is a constant. Therefore, for example, sizeof(char) is 1, because char type is one byte long. ","Until now, in all our programs, we have only had as much memory available as we declared for our variables, having the size of all of them to be determined in the source code, before the execution of the program. But, what if we need a variable amount of memory that can only be determined during runtime? For example, in the case that we need some user input to determine the necessary amount of memory space.\n\nThe answer is dynamic memory, for which C++ integrates the operators new and delete.\n\nOperators new and new[]\nIn order to request dynamic memory we use the operator new. new is followed by a data type specifier and -if a sequence of more than one element is required- the number of these within brackets []. It returns a pointer to the beginning of the new block of memory allocated. Its form is: \n\npointer = new type\npointer = new type [number_of_elements]\n\nThe first expression is used to allocate memory to contain one single element of type type. The second one is used to assign a block (an array) of elements of type type, where number_of_elements is an integer value representing the amount of these. For example:\n\n1\n2\nint * bobby;\nbobby = new int [5];\n\n\nIn this case, the system dynamically assigns space for five elements of type int and returns a pointer to the first element of the sequence, which is assigned to bobby. Therefore, now, bobby points to a valid block of memory with space for five elements of type int.\n","A class is an expanded concept of a data structure: instead of holding only data, it can hold both data and functions.\n\nAn object is an instantiation of a class. In terms of variables, a class would be the type, and an object would be the variable.\n\nClasses are generally declared using the keyword class, with the following format:\n\nclass class_name {\n access_specifier_1:\n member1;\n access_specifier_2:\n member2;\n ...\n } object_names;\n\nWhere class_name is a valid identifier for the class, object_names is an optional list of names for objects of this class. The body of the declaration can contain members, that can be either data or function declarations, and optionally access specifiers.\n\nAll is very similar to the declaration on data structures, except that we can now include also functions and members, but also this new thing called access specifier. An access specifier is one of the following three keywords: private, public or protected. These specifiers modify the access rights that the members following them acquire:\n\nprivate members of a class are accessible only from within other members of the same class or from their friends.\nprotected members are accessible from members of their same class and from their friends, but also from members of their derived classes.\nFinally, public members are accessible from anywhere where the object is visible.\n\nBy default, all members of a class declared with the class keyword have private access for all its members. Therefore, any member that is declared before one other class specifier automatically has private access. For example: \n\n1\n2\n3\n4\n5\n6\nclass CRectangle {\n int x, y;\n public:\n void set_values (int,int);\n int area (void);\n } rect;\n\n\nDeclares a class (i.e., a type) called CRectangle and an object (i.e., a variable) of this class called rect. This class contains four members: two data members of type int (member x and member y) with private access (because private is the default access level) and two member functions with public access: set_values() and area(), of which for now we have only included their declaration, not their definition.\n\nNotice the difference between the class name and the object name: In the previous example, CRectangle was the class name (i.e., the type), whereas rect was an object of type CRectangle. It is the same relationship int and a have in the following declaration:\n\n \nint a;\n\n\nwhere int is the type name (the class) and a is the variable name (the object). \n\nAfter the previous declarations of CRectangle and rect, we can refer within the body of the program to any of the public members of the object rect as if they were normal functions or normal variables, just by putting the object\'s name followed by a dot (.) and then the name of the member. All very similar to what we did with plain data structures before. For example: \n\n1\n2\nrect.set_values (3,4);\nmyarea = rect.area(); \n\n\nThe only members of rect that we cannot access from the body of our program outside the class are x and y, since they have private access and they can only be referred from within other members of that same class.\n\nHere is the complete example of class CRectangle:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n// classes example\n#include <iostream>\nusing namespace std;\n\nclass CRectangle {\n int x, y;\n public:\n void set_values (int,int);\n int area () {return (x*y);}\n};\n\nvoid CRectangle::set_values (int a, int b) {\n x = a;\n y = b;\n}\n\nint main () {\n CRectangle rect;\n rect.set_values (3,4);\n cout << \"area: \" << rect.area();\n return 0;\n}\narea: 12\n\n\nThe most important new thing in this code is the operator of scope (::, two colons) included in the definition of set_values(). It is used to define a member of a class from outside the class definition itself.\n\nYou may notice that the definition of the member function area() has been included directly within the definition of the CRectangle class given its extreme simplicity, whereas set_values() has only its prototype declared within the class, but its definition is outside it. In this outside definition, we must use the operator of scope (::) to specify that we are defining a function that is a member of the class CRectangle and not a regular global function.\n\nThe scope operator (::) specifies the class to which the member being declared belongs, granting exactly the same scope properties as if this function definition was directly included within the class definition. For example, in the function set_values() of the previous code, we have been able to use the variables x and y, which are private members of class CRectangle, which means they are only accessible from other members of their class.\n\nThe only difference between defining a class member function completely within its class or to include only the prototype and later its definition, is that in the first case the function will automatically be considered an inline member function by the compiler, while in the second it will be a normal (not-inline) class member function, which in fact supposes no difference in behavior.\n\nMembers x and y have private access (remember that if nothing else is said, all members of a class defined with keyword class have private access). By declaring them private we deny access to them from anywhere outside the class. This makes sense, since we have already defined a member function to set values for those members within the object: the member function set_values(). Therefore, the rest of the program does not need to have direct access to them. Perhaps in a so simple example as this, it is difficult to see any utility in protecting those two variables, but in greater projects it may be very important that values cannot be modified in an unexpected way (unexpected from the point of view of the object).\n\nOne of the greater advantages of a class is that, as any other type, we can declare several objects of it. For example, following with the previous example of class CRectangle, we could have declared the object rectb in addition to the object rect: \n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n// example: one class, two objects\n#include <iostream>\nusing namespace std;\n\nclass CRectangle {\n int x, y;\n public:\n void set_values (int,int);\n int area () {return (x*y);}\n};\n\nvoid CRectangle::set_values (int a, int b) {\n x = a;\n y = b;\n}\n\nint main () {\n CRectangle rect, rectb;\n rect.set_values (3,4);\n rectb.set_values (5,6);\n cout << \"rect area: \" << rect.area() << endl;\n cout << \"rectb area: \" << rectb.area() << endl;\n return 0;\n}\nrect area: 12\nrectb area: 30 \n\n\nIn this concrete case, the class (type of the objects) to which we are talking about is CRectangle, of which there are two instances or objects: rect and rectb. Each one of them has its own member variables and member functions.\n\nNotice that the call to rect.area() does not give the same result as the call to rectb.area(). This is because each object of class CRectangle has its own variables x and y, as they, in some way, have also their own function members set_value() and area() that each uses its object\'s own variables to operate.\n\nThat is the basic concept of object-oriented programming: Data and functions are both members of the object. We no longer use sets of global variables that we pass from one function to another as parameters, but instead we handle objects that have their own data and functions embedded as members. Notice that we have not had to give any parameters in any of the calls to rect.area or rectb.area. Those member functions directly used the data members of their respective objects rect and rectb.\n\nConstructors and destructors\nObjects generally need to initialize variables or assign dynamic memory during their process of creation to become operative and to avoid returning unexpected values during their execution. For example, what would happen if in the previous example we called the member function area() before having called function set_values()? Probably we would have gotten an undetermined result since the members x and y would have never been assigned a value.\n\nIn order to avoid that, a class can include a special function called constructor, which is automatically called whenever a new object of this class is created. This constructor function must have the same name as the class, and cannot have any return type; not even void.\n\nWe are going to implement CRectangle including a constructor: \n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n// example: class constructor\n#include <iostream>\nusing namespace std;\n\nclass CRectangle {\n int width, height;\n public:\n CRectangle (int,int);\n int area () {return (width*height);}\n};\n\nCRectangle::CRectangle (int a, int b) {\n width = a;\n height = b;\n}\n\nint main () {\n CRectangle rect (3,4);\n CRectangle rectb (5,6);\n cout << \"rect area: \" << rect.area() << endl;\n cout << \"rectb area: \" << rectb.area() << endl;\n return 0;\n}\nrect area: 12\nrectb area: 30 \n\n\nAs you can see, the result of this example is identical to the previous one. But now we have removed the member function set_values(), and have included instead a constructor that performs a similar action: it initializes the values of width and height with the parameters that are passed to it.\n\nNotice how these arguments are passed to the constructor at the moment at which the objects of this class are created:\n\n1\n2\nCRectangle rect (3,4);\nCRectangle rectb (5,6);\n\n\nConstructors cannot be called explicitly as if they were regular member functions. They are only executed when a new object of that class is created.\n\nYou can also see how neither the constructor prototype declaration (within the class) nor the latter constructor definition include a return value; not even void.\n\nThe destructor fulfills the opposite functionality. It is automatically called when an object is destroyed, either because its scope of existence has finished (for example, if it was defined as a local object within a function and the function ends) or because it is an object dynamically assigned and it is released using the operator delete.\n\nThe destructor must have the same name as the class, but preceded with a tilde sign (~) and it must also return no value.\n\nThe use of destructors is especially suitable when an object assigns dynamic memory during its lifetime and at the moment of being destroyed we want to release the memory that the object was allocated.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n// example on constructors and destructors\n#include <iostream>\nusing namespace std;\n\nclass CRectangle {\n int *width, *height;\n public:\n CRectangle (int,int);\n ~CRectangle ();\n int area () {return (*width * *height);}\n};\n\nCRectangle::CRectangle (int a, int b) {\n width = new int;\n height = new int;\n *width = a;\n *height = b;\n}\n\nCRectangle::~CRectangle () {\n delete width;\n delete height;\n}\n\nint main () {\n CRectangle rect (3,4), rectb (5,6);\n cout << \"rect area: \" << rect.area() << endl;\n cout << \"rectb area: \" << rectb.area() << endl;\n return 0;\n}\nrect area: 12\nrectb area: 30 \n\n\nOverloading Constructors\nLike any other function, a constructor can also be overloaded with more than one function that have the same name but different types or number of parameters. Remember that for overloaded functions the compiler will call the one whose parameters match the arguments used in the function call. In the case of constructors, which are automatically called when an object is created, the one executed is the one that matches the arguments passed on the object declaration:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n// overloading class constructors\n#include <iostream>\nusing namespace std;\n\nclass CRectangle {\n int width, height;\n public:\n CRectangle ();\n CRectangle (int,int);\n int area (void) {return (width*height);}\n};\n\nCRectangle::CRectangle () {\n width = 5;\n height = 5;\n}\n\nCRectangle::CRectangle (int a, int b) {\n width = a;\n height = b;\n}\n\nint main () {\n CRectangle rect (3,4);\n CRectangle rectb;\n cout << \"rect area: \" << rect.area() << endl;\n cout << \"rectb area: \" << rectb.area() << endl;\n return 0;\n}\nrect area: 12\nrectb area: 25 \n\n\nIn this case, rectb was declared without any arguments, so it has been initialized with the constructor that has no parameters, which initializes both width and height with a value of 5. \n\nImportant: Notice how if we declare a new object and we want to use its default constructor (the one without parameters), we do not include parentheses ():\n\n1\n2\nCRectangle rectb; // right\nCRectangle rectb(); // wrong! \n\n\nDefault constructor\nIf you do not declare any constructors in a class definition, the compiler assumes the class to have a default constructor with no arguments. Therefore, after declaring a class like this one:\n\n1\n2\n3\n4\n5\nclass CExample {\n public:\n int a,b,c;\n void multiply (int n, int m) { a=n; b=m; c=a*b; }\n };\n\n\nThe compiler assumes that CExample has a default constructor, so you can declare objects of this class by simply declaring them without any arguments:\n\n \nCExample ex;\n\n\nBut as soon as you declare your own constructor for a class, the compiler no longer provides an implicit default constructor. So you have to declare all objects of that class according to the constructor prototypes you defined for the class:\n\n1\n2\n3\n4\n5\n6\nclass CExample {\n public:\n int a,b,c;\n CExample (int n, int m) { a=n; b=m; };\n void multiply () { c=a*b; };\n };\n\n\nHere we have declared a constructor that takes two parameters of type int. Therefore the following object declaration would be correct:\n\n \nCExample ex (2,3);\n\nBut,\n \nCExample ex;\n\n\nWould not be correct, since we have declared the class to have an explicit constructor, thus replacing the default constructor.\n\nBut the compiler not only creates a default constructor for you if you do not specify your own. It provides three special member functions in total that are implicitly declared if you do not declare your own. These are the copy constructor, the copy assignment operator, and the default destructor.\n\nThe copy constructor and the copy assignment operator copy all the data contained in another object to the data members of the current object. For CExample, the copy constructor implicitly declared by the compiler would be something similar to:\n\n1\n2\n3\nCExample::CExample (const CExample& rv) {\n a=rv.a; b=rv.b; c=rv.c;\n }\n\n\nTherefore, the two following object declarations would be correct:\n\n1\n2\nCExample ex (2,3);\nCExample ex2 (ex); // copy constructor (data copied from ex) \n\n\nPointers to classes\nIt is perfectly valid to create pointers that point to classes. We simply have to consider that once declared, a class becomes a valid type, so we can use the class name as the type for the pointer. For example: \n\n \nCRectangle * prect;\n\n\nis a pointer to an object of class CRectangle.\n\nAs it happened with data structures, in order to refer directly to a member of an object pointed by a pointer we can use the arrow operator (->) of indirection. Here is an example with some possible combinations:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n// pointer to classes example\n#include <iostream>\nusing namespace std;\n\nclass CRectangle {\n int width, height;\n public:\n void set_values (int, int);\n int area (void) {return (width * height);}\n};\n\nvoid CRectangle::set_values (int a, int b) {\n width = a;\n height = b;\n}\n\nint main () {\n CRectangle a, *b, *c;\n CRectangle * d = new CRectangle[2];\n b= new CRectangle;\n c= &a;\n a.set_values (1,2);\n b->set_values (3,4);\n d->set_values (5,6);\n d[1].set_values (7,8);\n cout << \"a area: \" << a.area() << endl;\n cout << \"*b area: \" << b->area() << endl;\n cout << \"*c area: \" << c->area() << endl;\n cout << \"d[0] area: \" << d[0].area() << endl;\n cout << \"d[1] area: \" << d[1].area() << endl;\n delete[] d;\n delete b;\n return 0;\n}\na area: 2\n*b area: 12\n*c area: 2\nd[0] area: 30\nd[1] area: 56\n\n\nNext you have a summary on how can you read some pointer and class operators (*, &, ., ->, [ ]) that appear in the previous example:\n\nexpression\tcan be read as\n*x\tpointed by x\n&x\taddress of x\nx.y\tmember y of object x\nx->y\tmember y of object pointed by x\n(*x).y\tmember y of object pointed by x (equivalent to the previous one)\nx[0]\tfirst object pointed by x\nx[1]\tsecond object pointed by x\nx[n]\t(n+1)th object pointed by x\n\nBe sure that you understand the logic under all of these expressions before proceeding with the next sections. If you have doubts, read again this section and/or consult the previous sections about pointers and data structures.\n\nClasses defined with struct and union\nClasses can be defined not only with keyword class, but also with keywords struct and union.\n\nThe concepts of class and data structure are so similar that both keywords (struct and class) can be used in C++ to declare classes (i.e. structs can also have function members in C++, not only data members). The only difference between both is that members of classes declared with the keyword struct have public access by default, while members of classes declared with the keyword class have private access. For all other purposes both keywords are equivalent.\n\nThe concept of unions is different from that of classes declared with struct and class, since unions only store one data member at a time, but nevertheless they are also classes and can thus also hold function members. The default access in union classes is public.\n" ,"Overloading operators\nC++ incorporates the option to use standard operators to perform operations with classes in addition to with fundamental types. For example:\n\n1\n2\nint a, b, c;\na = b + c;\n\n\nThis is obviously valid code in C++, since the different variables of the addition are all fundamental types. Nevertheless, it is not so obvious that we could perform an operation similar to the following one:\n\n1\n2\n3\n4\n5\nstruct {\n string product;\n float price;\n} a, b, c;\na = b + c; \n\n\nIn fact, this will cause a compilation error, since we have not defined the behavior our class should have with addition operations. However, thanks to the C++ feature to overload operators, we can design classes able to perform operations using standard operators. Here is a list of all the operators that can be overloaded:\n\nOverloadable operators\n+ - * / = < > += -= *= /= << >>\n<<= >>= == != <= >= ++ -- % & ^ ! |\n~ &= ^= |= && || %= [] () , ->* -> new \ndelete new[] delete[]\n\nTo overload an operator in order to use it with classes we declare operator functions, which are regular functions whose names are the operator keyword followed by the operator sign that we want to overload. The format is:\n\ntype operator sign (parameters) { /*...*/ }\n\nHere you have an example that overloads the addition operator (+). We are going to create a class to store bidimensional vectors and then we are going to add two of them: a(3,1) and b(1,2). The addition of two bidimensional vectors is an operation as simple as adding the two x coordinates to obtain the resulting x coordinate and adding the two y coordinates to obtain the resulting y. In this case the result will be (3+1,1+2) = (4,3).\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n// vectors: overloading operators example\n#include <iostream>\nusing namespace std;\n\nclass CVector {\n public:\n int x,y;\n CVector () {};\n CVector (int,int);\n CVector operator + (CVector);\n};\n\nCVector::CVector (int a, int b) {\n x = a;\n y = b;\n}\n\nCVector CVector::operator+ (CVector param) {\n CVector temp;\n temp.x = x + param.x;\n temp.y = y + param.y;\n return (temp);\n}\n\nint main () {\n CVector a (3,1);\n CVector b (1,2);\n CVector c;\n c = a + b;\n cout << c.x << \",\" << c.y;\n return 0;\n}\n4,3\n\n\nIt may be a little confusing to see so many times the CVector identifier. But, consider that some of them refer to the class name (type) CVector and some others are functions with that name (constructors must have the same name as the class). Do not confuse them:\n\n1\n2\nCVector (int, int); // function name CVector (constructor)\nCVector operator+ (CVector); // function returns a CVector \n\n\nThe function operator+ of class CVector is the one that is in charge of overloading the addition operator (+). This function can be called either implicitly using the operator, or explicitly using the function name:\n\n1\n2\nc = a + b;\nc = a.operator+ (b);\n\n\nBoth expressions are equivalent.\n\nNotice also that we have included the empty constructor (without parameters) and we have defined it with an empty block:\n\n \nCVector () { };\n\n\nThis is necessary, since we have explicitly declared another constructor:\n\n \nCVector (int, int);\n\n\nAnd when we explicitly declare any constructor, with any number of parameters, the default constructor with no parameters that the compiler can declare automatically is not declared, so we need to declare it ourselves in order to be able to construct objects of this type without parameters. Otherwise, the declaration:\n\n \nCVector c;\n\n\nincluded in main() would not have been valid.\n\nAnyway, I have to warn you that an empty block is a bad implementation for a constructor, since it does not fulfill the minimum functionality that is generally expected from a constructor, which is the initialization of all the member variables in its class. In our case this constructor leaves the variables x and y undefined. Therefore, a more advisable definition would have been something similar to this:\n\n \nCVector () { x=0; y=0; };\n\n\nwhich in order to simplify and show only the point of the code I have not included in the example.\n\nAs well as a class includes a default constructor and a copy constructor even if they are not declared, it also includes a default definition for the assignment operator (=) with the class itself as parameter. The behavior which is defined by default is to copy the whole content of the data members of the object passed as argument (the one at the right side of the sign) to the one at the left side:\n\n1\n2\n3\nCVector d (2,3);\nCVector e;\ne = d; // copy assignment operator \n\n\nThe copy assignment operator function is the only operator member function implemented by default. Of course, you can redefine it to any other functionality that you want, like for example, copy only certain class members or perform additional initialization procedures.\n\nThe overload of operators does not force its operation to bear a relation to the mathematical or usual meaning of the operator, although it is recommended. For example, the code may not be very intuitive if you use operator + to subtract two classes or operator== to fill with zeros a class, although it is perfectly possible to do so.\n\nAlthough the prototype of a function operator+ can seem obvious since it takes what is at the right side of the operator as the parameter for the operator member function of the object at its left side, other operators may not be so obvious. Here you have a table with a summary on how the different operator functions have to be declared (replace @ by the operator in each case):\n\nExpression\tOperator\tMember function\tGlobal function\n@a\t+ - * & ! ~ ++ --\tA::operator@()\toperator@(A)\na@\t++ --\tA::operator@(int)\toperator@(A,int)\na@b\t+ - * / % ^ & | < > == != <= >= << >> && || ,\tA::operator@ (B)\toperator@(A,B)\na@b\t= += -= *= /= %= ^= &= |= <<= >>= []\tA::operator@ (B)\t-\na(b, c...)\t()\tA::operator() (B, C...)\t-\na->x\t->\tA::operator->()\t-\nWhere a is an object of class A, b is an object of class B and c is an object of class C.\n\nYou can see in this panel that there are two ways to overload some class operators: as a member function and as a global function. Its use is indistinct, nevertheless I remind you that functions that are not members of a class cannot access the private or protected members of that class unless the global function is its friend (friendship is explained later).","Friend functions\nIn principle, private and protected members of a class cannot be accessed from outside the same class in which they are declared. However, this rule does not affect friends.\n\nFriends are functions or classes declared with the friend keyword.\n\nIf we want to declare an external function as friend of a class, thus allowing this function to have access to the private and protected members of this class, we do it by declaring a prototype of this external function within the class, and preceding it with the keyword friend:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n// friend functions\n#include <iostream>\nusing namespace std;\n\nclass CRectangle {\n int width, height;\n public:\n void set_values (int, int);\n int area () {return (width * height);}\n friend CRectangle duplicate (CRectangle);\n};\n\nvoid CRectangle::set_values (int a, int b) {\n width = a;\n height = b;\n}\n\nCRectangle duplicate (CRectangle rectparam)\n{\n CRectangle rectres;\n rectres.width = rectparam.width*2;\n rectres.height = rectparam.height*2;\n return (rectres);\n}\n\nint main () {\n CRectangle rect, rectb;\n rect.set_values (2,3);\n rectb = duplicate (rect);\n cout << rectb.area();\n return 0;\n}\n24 \n\n\nThe duplicate function is a friend of CRectangle. From within that function we have been able to access the members width and height of different objects of type CRectangle, which are private members. Notice that neither in the declaration of duplicate() nor in its later use in main() have we considered duplicate a member of class CRectangle. It isn\'t! It simply has access to its private and protected members without being a member.\n\nThe friend functions can serve, for example, to conduct operations between two different classes. Generally, the use of friend functions is out of an object-oriented programming methodology, so whenever possible it is better to use members of the same class to perform operations with them. Such as in the previous example, it would have been shorter to integrate duplicate() within the class CRectangle.\n\nFriend classes\nJust as we have the possibility to define a friend function, we can also define a class as friend of another one, granting that first class access to the protected and private members of the second one.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n// friend class\n#include <iostream>\nusing namespace std;\n\nclass CSquare;\n\nclass CRectangle {\n int width, height;\n public:\n int area ()\n {return (width * height);}\n void convert (CSquare a);\n};\n\nclass CSquare {\n private:\n int side;\n public:\n void set_side (int a)\n {side=a;}\n friend class CRectangle;\n};\n\nvoid CRectangle::convert (CSquare a) {\n width = a.side;\n height = a.side;\n}\n \nint main () {\n CSquare sqr;\n CRectangle rect;\n sqr.set_side(4);\n rect.convert(sqr);\n cout << rect.area();\n return 0;\n}\n16\n\n\nIn this example, we have declared CRectangle as a friend of CSquare so that CRectangle member functions could have access to the protected and private members of CSquare, more concretely to CSquare::side, which describes the side width of the square.\n\nYou may also see something new at the beginning of the program: an empty declaration of class CSquare. This is necessary because within the declaration of CRectangle we refer to CSquare (as a parameter in convert()). The definition of CSquare is included later, so if we did not include a previous empty declaration for CSquare this class would not be visible from within the definition of CRectangle.\n\nConsider that friendships are not corresponded if we do not explicitly specify so. In our example, CRectangle is considered as a friend class by CSquare, but CRectangle does not consider CSquare to be a friend, so CRectangle can access the protected and private members of CSquare but not the reverse way. Of course, we could have declared also CSquare as friend of CRectangle if we wanted to.\n\nAnother property of friendships is that they are not transitive: The friend of a friend is not considered to be a friend unless explicitly specified.\n\nInheritance between classes\nA key feature of C++ classes is inheritance. Inheritance allows to create classes which are derived from other classes, so that they automatically include some of its \"parent\'s\" members, plus its own. For example, we are going to suppose that we want to declare a series of classes that describe polygons like our CRectangle, or like CTriangle. They have certain common properties, such as both can be described by means of only two sides: height and base.\n\nThis could be represented in the world of classes with a class CPolygon from which we would derive the two other ones: CRectangle and CTriangle.\n\n \nThe class CPolygon would contain members that are common for both types of polygon. In our case: width and height. And CRectangle and CTriangle would be its derived classes, with specific features that are different from one type of polygon to the other.\n\nClasses that are derived from others inherit all the accessible members of the base class. That means that if a base class includes a member A and we derive it to another class with another member called B, the derived class will contain both members A and B.\n\nIn order to derive a class from another, we use a colon (:) in the declaration of the derived class using the following format: \n\nclass derived_class_name: public base_class_name\n{ /*...*/ };\n\nWhere derived_class_name is the name of the derived class and base_class_name is the name of the class on which it is based. The public access specifier may be replaced by any one of the other access specifiers protected and private. This access specifier limits the most accessible level for the members inherited from the base class: The members with a more accessible level are inherited with this level instead, while the members with an equal or more restrictive access level keep their restrictive level in the derived class.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n// derived classes\n#include <iostream>\nusing namespace std;\n\nclass CPolygon {\n protected:\n int width, height;\n public:\n void set_values (int a, int b)\n { width=a; height=b;}\n };\n\nclass CRectangle: public CPolygon {\n public:\n int area ()\n { return (width * height); }\n };\n\nclass CTriangle: public CPolygon {\n public:\n int area ()\n { return (width * height / 2); }\n };\n \nint main () {\n CRectangle rect;\n CTriangle trgl;\n rect.set_values (4,5);\n trgl.set_values (4,5);\n cout << rect.area() << endl;\n cout << trgl.area() << endl;\n return 0;\n}\n20\n10\n\n\nThe objects of the classes CRectangle and CTriangle each contain members inherited from CPolygon. These are: width, height and set_values().\n\nThe protected access specifier is similar to private. Its only difference occurs in fact with inheritance. When a class inherits from another one, the members of the derived class can access the protected members inherited from the base class, but not its private members.\n\nSince we wanted width and height to be accessible from members of the derived classes CRectangle and CTriangle and not only by members of CPolygon, we have used protected access instead of private.\n\nWe can summarize the different access types according to who can access them in the following way: \n\nAccess\tpublic\tprotected\tprivate\nmembers of the same class\tyes\tyes\tyes\nmembers of derived classes\tyes\tyes\tno\nnot members\tyes\tno\tno\n\nWhere \"not members\" represent any access from outside the class, such as from main(), from another class or from a function.\n\nIn our example, the members inherited by CRectangle and CTriangle have the same access permissions as they had in their base class CPolygon:\n\n1\n2\n3\n4\n5\nCPolygon::width // protected access\nCRectangle::width // protected access\n\nCPolygon::set_values() // public access\nCRectangle::set_values() // public access \n\n\nThis is because we have used the public keyword to define the inheritance relationship on each of the derived classes:\n\n \nclass CRectangle: public CPolygon { ... }\n\n\nThis public keyword after the colon (:) denotes the most accessible level the members inherited from the class that follows it (in this case CPolygon) will have. Since public is the most accessible level, by specifying this keyword the derived class will inherit all the members with the same levels they had in the base class.\n\nIf we specify a more restrictive access level like protected, all public members of the base class are inherited as protected in the derived class. Whereas if we specify the most restricting of all access levels: private, all the base class members are inherited as private.\n\nFor example, if daughter was a class derived from mother that we defined as:\n\n \nclass daughter: protected mother;\n\n\nThis would set protected as the maximum access level for the members of daughter that it inherited from mother. That is, all members that were public in mother would become protected in daughter. Of course, this would not restrict daughter to declare its own public members. That maximum access level is only set for the members inherited from mother.\n\nIf we do not explicitly specify any access level for the inheritance, the compiler assumes private for classes declared with class keyword and public for those declared with struct.\n\nWhat is inherited from the base class?\nIn principle, a derived class inherits every member of a base class except:\n\nits constructor and its destructor\nits operator=() members\nits friends\n\nAlthough the constructors and destructors of the base class are not inherited themselves, its default constructor (i.e., its constructor with no parameters) and its destructor are always called when a new object of a derived class is created or destroyed.\n\nIf the base class has no default constructor or you want that an overloaded constructor is called when a new derived object is created, you can specify it in each constructor definition of the derived class:\n\nderived_constructor_name (parameters) : base_constructor_name (parameters) {...}\n\nFor example: \n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n// constructors and derived classes\n#include <iostream>\nusing namespace std;\n\nclass mother {\n public:\n mother ()\n { cout << \"mother: no parameters\\n\"; }\n mother (int a)\n { cout << \"mother: int parameter\\n\"; }\n};\n\nclass daughter : public mother {\n public:\n daughter (int a)\n { cout << \"daughter: int parameter\\n\\n\"; }\n};\n\nclass son : public mother {\n public:\n son (int a) : mother (a)\n { cout << \"son: int parameter\\n\\n\"; }\n};\n\nint main () {\n daughter cynthia (0);\n son daniel(0);\n \n return 0;\n}\nmother: no parameters\ndaughter: int parameter\n \nmother: int parameter\nson: int parameter\n\n\nNotice the difference between which mother\'s constructor is called when a new daughter object is created and which when it is a son object. The difference is because the constructor declaration of daughter and son:\n\n1\n2\ndaughter (int a) // nothing specified: call default\nson (int a) : mother (a) // constructor specified: call this \n\n\nMultiple inheritance\nIn C++ it is perfectly possible that a class inherits members from more than one class. This is done by simply separating the different base classes with commas in the derived class declaration. For example, if we had a specific class to print on screen (COutput) and we wanted our classes CRectangle and CTriangle to also inherit its members in addition to those of CPolygon we could write: \n\n1\n2\nclass CRectangle: public CPolygon, public COutput;\nclass CTriangle: public CPolygon, public COutput; \n\n\nhere is the complete example: \n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n// multiple inheritance\n#include <iostream>\nusing namespace std;\n\nclass CPolygon {\n protected:\n int width, height;\n public:\n void set_values (int a, int b)\n { width=a; height=b;}\n };\n\nclass COutput {\n public:\n void output (int i);\n };\n\nvoid COutput::output (int i) {\n cout << i << endl;\n }\n\nclass CRectangle: public CPolygon, public COutput {\n public:\n int area ()\n { return (width * height); }\n };\n\nclass CTriangle: public CPolygon, public COutput {\n public:\n int area ()\n { return (width * height / 2); }\n };\n \nint main () {\n CRectangle rect;\n CTriangle trgl;\n rect.set_values (4,5);\n trgl.set_values (4,5);\n rect.output (rect.area());\n trgl.output (trgl.area());\n return 0;\n}\n20\n10","Exceptions provide a way to react to exceptional circumstances (like runtime errors) in our program by transferring control to special functions called handlers.\n\nTo catch exceptions we must place a portion of code under exception inspection. This is done by enclosing that portion of code in a try block. When an exceptional circumstance arises within that block, an exception is thrown that transfers the control to the exception handler. If no exception is thrown, the code continues normally and all handlers are ignored.\n\nAn exception is thrown by using the throw keyword from inside the try block. Exception handlers are declared with the keyword catch, which must be placed immediately after the try block:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n// exceptions\n#include <iostream>\nusing namespace std;\n\nint main () {\n try\n {\n throw 20;\n }\n catch (int e)\n {\n cout << \"An exception occurred. Exception Nr. \" << e << endl;\n }\n return 0;\n}\nAn exception occurred. Exception Nr. 20\n\n\nThe code under exception handling is enclosed in a try block. In this example this code simply throws an exception:\n\n \nthrow 20;\n\n\nA throw expression accepts one parameter (in this case the integer value 20), which is passed as an argument to the exception handler.\n\nThe exception handler is declared with the catch keyword. As you can see, it follows immediately the closing brace of the try block. The catch format is similar to a regular function that always has at least one parameter. The type of this parameter is very important, since the type of the argument passed by the throw expression is checked against it, and only in the case they match, the exception is caught.\n\nWe can chain multiple handlers (catch expressions), each one with a different parameter type. Only the handler that matches its type with the argument specified in the throw statement is executed.\n\nIf we use an ellipsis (...) as the parameter of catch, that handler will catch any exception no matter what the type of the throw exception is. This can be used as a default handler that catches all exceptions not caught by other handlers if it is specified at last:\n\n1\n2\n3\n4\n5\n6\ntry {\n // code here\n}\ncatch (int param) { cout << \"int exception\"; }\ncatch (char param) { cout << \"char exception\"; }\ncatch (...) { cout << \"default exception\"; }\n\n\nIn this case the last handler would catch any exception thrown with any parameter that is neither an int nor a char.\n\nAfter an exception has been handled the program execution resumes after the try-catch block, not after the throw statement!.\n\nIt is also possible to nest try-catch blocks within more external try blocks. In these cases, we have the possibility that an internal catch block forwards the exception to its external level. This is done with the expression throw; with no arguments. For example: \n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\ntry {\n try {\n // code here\n }\n catch (int n) {\n throw;\n }\n}\ncatch (...) {\n cout << \"Exception occurred\";\n}\n\n\nException specifications\n\nWhen declaring a function we can limit the exception type it might directly or indirectly throw by appending a throw suffix to the function declaration:\n\n \nfloat myfunction (char param) throw (int);\n\n\nThis declares a function called myfunction which takes one argument of type char and returns an element of type float. The only exception that this function might throw is an exception of type int. If it throws an exception with a different type, either directly or indirectly, it cannot be caught by a regular int-type handler.\n\nIf this throw specifier is left empty with no type, this means the function is not allowed to throw exceptions. Functions with no throw specifier (regular functions) are allowed to throw exceptions with any type:\n\n1\n2\nint myfunction (int param) throw(); // no exceptions allowed\nint myfunction (int param); // all exceptions allowed \n\n\nStandard exceptions\nThe C++ Standard library provides a base class specifically designed to declare objects to be thrown as exceptions. It is called exception and is defined in the <exception> header file under the namespace std. This class has the usual default and copy constructors, operators and destructors, plus an additional virtual member function called what that returns a null-terminated character sequence (char *) and that can be overwritten in derived classes to contain some sort of description of the exception.\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n// standard exceptions\n#include <iostream>\n#include <exception>\nusing namespace std;\n\nclass myexception: public exception\n{\n virtual const char* what() const throw()\n {\n return \"My exception happened\";\n }\n} myex;\n\nint main () {\n try\n {\n throw myex;\n }\n catch (exception& e)\n {\n cout << e.what() << endl;\n }\n return 0;\n}\nMy exception happened.\n\n\nWe have placed a handler that catches exception objects by reference (notice the ampersand & after the type), therefore this catches also classes derived from exception, like our myex object of class myexception.\n\nAll exceptions thrown by components of the C++ Standard library throw exceptions derived from this std::exception class. These are:\n\nexception\tdescription\nbad_alloc\tthrown by new on allocation failure\nbad_cast\tthrown by dynamic_cast when fails with a referenced type\nbad_exception\tthrown when an exception type doesn\'t match any catch\nbad_typeid\tthrown by typeid\nios_base::failure\tthrown by functions in the iostream library\n\nFor example, if we use the operator new and the memory cannot be allocated, an exception of type bad_alloc is thrown:\n\n1\n2\n3\n4\n5\n6\n7\n8\ntry\n{\n int * myarray= new int[1000];\n}\ncatch (bad_alloc&)\n{\n cout << \"Error allocating memory.\" << endl;\n}\n\n\nIt is recommended to include all dynamic memory allocations within a try block that catches this type of exception to perform a clean action instead of an abnormal program termination, which is what happens when this type of exception is thrown and not caught. If you want to force a bad_alloc exception to see it in action, you can try to allocate a huge array; On my system, trying to allocate 1 billion ints threw a bad_alloc exception.\n\nBecause bad_alloc is derived from the standard base class exception, we can handle that same exception by catching references to the exception class:\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n// bad_alloc standard exception\n#include <iostream>\n#include <exception>\nusing namespace std;\n\nint main () {\n try\n {\n int* myarray= new int[1000];\n }\n catch (exception& e)\n {\n cout << \"Standard exception: \" << e.what() << endl;\n }\n return 0;\n}"};
	
	String filename="file";
	FileOutputStream fos;
	WakeLock wl;

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		// TODO Auto-generated method stub
	/*	SharedPreferences getprefs=PreferenceManager.getDefaultSharedPreferences(getBaseContext());
		boolean lock=getprefs.getBoolean("wlock", false);
		
		if(lock==true)
		{
			PowerManager pm=(PowerManager)getSystemService(Context.POWER_SERVICE); 
			wl=pm.newWakeLock(PowerManager.FULL_WAKE_LOCK, "what");
		}
*/
		super.onCreate(savedInstanceState);
		fscreen();
	//	wl.acquire();
		setContentView(R.layout.lang);
		String aa;
		SharedPreferences bookmark;
		t = (TextView) findViewById(R.id.maintext);
		t1 = (TextView) findViewById(R.id.heading);
		editnotes=(EditText)findViewById(R.id.editnotes);
		t1.setTextColor(Color.RED);
		 prev = (Button) findViewById(R.id.prev);
		 next = (Button) findViewById(R.id.next);
		 booksave=(Button)findViewById(R.id.booksave);
		 bookdisplay=(Button)findViewById(R.id.bookdisplay);
		 savenotes = (Button) findViewById(R.id.savenotes);
		 displaynotes = (Button) findViewById(R.id.displaynotes);
		 sd=(SlidingDrawer)findViewById(R.id.sld1);
		 sd.setOnDrawerOpenListener(this);
		 sd.setOnDrawerCloseListener(this);
		 booksave.setOnClickListener(this);
		 bookdisplay.setOnClickListener(this);
		 prev.setOnClickListener(this);
		 next.setOnClickListener(this);
		 savenotes.setOnClickListener(this);
		 displaynotes.setOnClickListener(this);
	     ActionBar actionBar1 = getActionBar();
	     actionBar1.setDisplayHomeAsUpEnabled(true);
		 
		 
		 try {
			fos=openFileOutput("abcd",MODE_PRIVATE | MODE_APPEND);
			fos.close();
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		 
		 
		 bookmark=getSharedPreferences(filename,0);
				Bundle gotbasket = getIntent().getExtras();
				var = gotbasket.getString("a1");
				 
		while(ii < 12){
	
			String ss = optionsc[ii];
			if (var.equals(ss))
			{

			break;
			}
			else
			{
				ii++;
			}
		}
		t.setText(optionscvalues[ii]);
		t1.setText(optionsc[ii]);
		getcolor();
		getsize();

		
		

		
		

	}
	

	
	private void getsize() {
		// TODO Auto-generated method stub
		
		
		SharedPreferences getpref=PreferenceManager.getDefaultSharedPreferences(getBaseContext());
		String fsize=getpref.getString("fsize", "s1") ;

		
			if(fsize.contentEquals("s1"))
		{
			t.setTextSize(25);
		}
		
		else if(fsize.contentEquals("s2"))
		{
			t.setTextSize(30);
		}

		else if(fsize.contentEquals("s3"))
		{
			t.setTextSize(35);
		}

		else if(fsize.contentEquals("s4"))
		{
			t.setTextSize(40);
		}

		else if(fsize.contentEquals("s5"))
		{
			t.setTextSize(45);
		}

		else if(fsize.contentEquals("s6"))
		{
			t.setTextSize(50);
		}


		
	}


	void fscreen() {
		// TODO Auto-generated method stub
	
	SharedPreferences getprefs=PreferenceManager.getDefaultSharedPreferences(getBaseContext());
	boolean screen=getprefs.getBoolean("fscreen", false);
	
	if(screen==true)
	{
		requestWindowFeature(Window.FEATURE_NO_TITLE);
		getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);

	}

		
	}

	
	private void getcolor() {
		// TODO Auto-generated method stub
		
		SharedPreferences getpref=PreferenceManager.getDefaultSharedPreferences(getBaseContext());
		String fcolor=getpref.getString("fcolor", "Black") ;
		
		
		if(fcolor.contentEquals("Black"))
	{
		t.setTextColor(Color.BLACK);
	}
	
	else if(fcolor.contentEquals("Blue"))
	{
		t.setTextColor(Color.BLUE);
	}

	else if(fcolor.contentEquals("Red"))
	{
		t.setTextColor(Color.RED);
	}
	else if(fcolor.contentEquals("Cyan"))
	{
		t.setTextColor(Color.CYAN);
	}
	else if(fcolor.contentEquals("Gray"))
	{
		t.setTextColor(Color.GRAY);
	}
	else if(fcolor.contentEquals("Green"))
	{
		t.setTextColor(Color.GREEN);
	}
		
		
	}

String data="";

	@Override
	public void onClick(View v) {
		// TODO Auto-generated method stub
		switch(v.getId())
		{
		case R.id.prev:
			
			ii--;
			if(ii<0)
			{
				ii=(optionsc.length)-1;
			}
			t.setText(optionscvalues[ii]);
			t1.setText(optionsc[ii]);
			getcolor();
			getsize();
			  Vibrator v12 = (Vibrator)getSystemService(Context.VIBRATOR_SERVICE);
			  v12.vibrate(100);

			break;
		case R.id.next:
			
			ii++;
			if(ii>((optionsc.length)-1))
			{
				ii=0;
			}

			t.setText(optionscvalues[ii]);
			t1.setText(optionsc[ii]);
			getcolor();
			getsize();
			  Vibrator v23 = (Vibrator)getSystemService(Context.VIBRATOR_SERVICE);
			  v23.vibrate(100);

			break;
			
		case R.id.booksave :
			int jx;
			 jx=ii;
			 String bookvalue=Integer.toString(jx);
			 bookmark=getSharedPreferences(filename,0);
			 String bm=bookmark.getString("starting", "");
			 String cm=bookmark.getString("pass", "");
			 database12 sd= new database12(this);
			 sd.open();
			 int f=sd.updateEntrycpp(bm,cm,bookvalue);
			 sd.close();
			 //t.setText(bm + "and " +cm );
			 
				/*			int start=s.indexOf("");
				String startingname=s.substring(start); */
			 if(f==1)
			 {
			Toast toast = Toast.makeText(langreader1.this, "bookmark page saved",Toast.LENGTH_LONG);	
			toast.show();
			 }

			break;
		
		case R.id.bookdisplay :
			 bookmark=getSharedPreferences(filename,0);
			 String bm1=bookmark.getString("starting", "");
			 String cm1=bookmark.getString("pass", "");

			 database12 sd1= new database12(this);
			 sd1.open();
			 String fa=sd1.validatebookcpp(bm1,cm1);
			 sd1.close();
			 int y=Integer.parseInt(fa);

			
			t.setText(optionscvalues[y]);
			t1.setText(optionsc[y]);


			Toast toast1 = Toast.makeText(langreader1.this, "bookmark page opened",Toast.LENGTH_LONG);			
			toast1.show();   

			break;
			
			
		case R.id.savenotes :
			 String timezoneID = TimeZone.getDefault().getID();
			/* SimpleDateFormat sdf2 = new SimpleDateFormat("dd-MMM-yyyy");
			 sdf2.setTimeZone(TimeZone.getTimeZone(timezoneID));*/
			 
		//	 Log.d("Time zone","="+tz.getDisplayName());
		//	 String time = "";
			 TimeZone tz = TimeZone.getTimeZone("GMT+05:30");
			 Calendar c = Calendar.getInstance(tz);
		//	 String d=c.get(Calendar.DATE);
			 
			 String time = "DATE :"+c.get(Calendar.DATE)+ " "+/*c.get(Calendar.NOVEMBER)*/"11" +"  "+c.get(Calendar.YEAR) 
					 +"   TIME : "+c.get(Calendar.HOUR_OF_DAY)+":"+c.get(Calendar.MINUTE)+":"+c.get(Calendar.SECOND);
			 data="C++ LANGUAGE"+"\n"+time + "\n" + editnotes.getText().toString() + "\n\n";
			 bookmark=getSharedPreferences(filename,0);
			 String bm2=bookmark.getString("starting","");
			 String cm2=bookmark.getString("pass","");
			 String dm2=bm2.concat(cm2);
			 
		     

			try {
				fos=openFileOutput(dm2,MODE_PRIVATE | MODE_APPEND);
				fos.write(data.getBytes());
				fos.close();

			} catch (FileNotFoundException e) {
				// TODO Auto-generated catch block
				
				e.printStackTrace();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
				
			}

			Toast toast111 = Toast.makeText(langreader1.this, "Notes Saved",Toast.LENGTH_LONG);			
			toast111.show();   
			editnotes.setText("");
			
			break;
			
		case R.id.displaynotes :
			
			String collected=null;
			FileInputStream fis=null;
			 bookmark=getSharedPreferences(filename,0);
			 String bm4=bookmark.getString("starting", "");
			 String cm4=bookmark.getString("pass", "");
			 String dm4=bm4.concat(cm4);

			try {
				fis=openFileInput(dm4);
				byte[] dataArray =new byte[fis.available()];
				while(fis.read(dataArray)!=-1)
				{
					collected=new String(dataArray);
				}
			} catch (FileNotFoundException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			finally
			{
				try {
					fis.close();
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
			
			Bundle basket=new Bundle();
			basket.putString("collect", collected);
			Intent a=new Intent(langreader1.this,displaynotes.class);
			a.putExtras(basket);
			startActivity(a);	

			Toast toast134 = Toast.makeText(langreader1.this, "Here's Your Notes",Toast.LENGTH_LONG);			
			toast134.show();   

			
			
			break;


			
			
		}
	}



	@Override
	public void onDrawerOpened() {
		// TODO Auto-generated method stub
		
		MediaPlayer Oursong=MediaPlayer.create(langreader1.this, R.raw.slider);
		Oursong.start();

		
	}



	@Override
	public void onDrawerClosed() {
		// TODO Auto-generated method stub
		
		MediaPlayer Oursong=MediaPlayer.create(langreader1.this, R.raw.slider);
		Oursong.start();

		
	}
	
	
	
	
	

	
	
	


	public boolean onCreateOptionsMenu(android.view.Menu menu) {
		// TODO Auto-generated method stub
		super.onCreateOptionsMenu(menu);
		MenuInflater blowup=getMenuInflater();
		blowup.inflate(R.menu.main, menu);
		return true;
	}






	public boolean onOptionsItemSelected(MenuItem item) {
		// TODO Auto-generated method stub
		//return super.onOptionsItemSelected(item);
		switch(item.getItemId())
		{
		case (R.id.about):
		Intent i=new Intent("net.com.example.pllv1.ABOUTUS");
		startActivity(i);
		break;
		
		case (R.id.pref):
			Intent s=new Intent("net.com.example.pllv1.PREFFS");
			startActivity(s);
			
			break;
		case (R.id.exit):
			//finish();
			System.exit(0);
		default:         startActivity(new Intent(langreader1.this,cpp.class));
		}
		return false;
	}



	@Override
	protected void onPause() {
		// TODO Auto-generated method stub
		super.onPause();
//		wl.release();
	}

	
	
	
}
