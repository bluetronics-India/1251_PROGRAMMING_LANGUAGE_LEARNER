package net.com.example.pllv1;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Calendar;
import java.util.TimeZone;

import android.app.ActionBar;
import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.graphics.Color;
import android.media.MediaPlayer;
import android.os.Bundle;
import android.os.PowerManager;
import android.os.PowerManager.WakeLock;
import android.os.Vibrator;
import android.preference.PreferenceManager;
import android.view.MenuInflater;
import android.view.MenuItem;
import android.view.View;
import android.view.View.OnClickListener;
import android.view.Window;
import android.view.WindowManager;
import android.widget.Button;
import android.widget.EditText;
import android.widget.SlidingDrawer;
import android.widget.SlidingDrawer.OnDrawerCloseListener;
import android.widget.SlidingDrawer.OnDrawerOpenListener;
//import android.widget.SlidingDrawer;
import android.widget.TextView;
import android.widget.Toast;

public class langreader2 extends Activity  implements OnClickListener, OnDrawerOpenListener, OnDrawerCloseListener {


		
	TextView t,t1;
	Button booksave,bookdisplay;
	@SuppressWarnings("deprecation")
	SlidingDrawer sd;
	int ii = 0;
	Button prev, next , savenotes,displaynotes;
	EditText editnotes;
	SharedPreferences bookmark;
	String var,data="";
	String optionsc[] = {  "INTRO", "Objects and Classes", "Java Variable Types",	"Java Loops - for, while and do...while", "Numbers Class", "Decision Making", "String Class", "Methods", " Streams, Files and I/O", "Exceptions Handling"  };
	String optionscvalues[] = { "Java programming language was originally developed by Sun Microsystems which was initiated by James Gosling and released in 1995 as core component of Sun Microsystems\' Java platform (Java 1.0 [J2SE]).\n\nAs of December 2008, the latest release of the Java Standard Edition is 6 (J2SE). With the advancement of Java and its widespread popularity, multiple configurations were built to suite various types of platforms. Ex: J2EE for Enterprise Applications, J2ME for Mobile Applications.\n\nSun Microsystems has renamed the new J2 versions as Java SE, Java EE and Java ME respectively. Java is guaranteed to be Write Once, Run Anywhere.\n\nJava is:\n\nObject Oriented: In Java, everything is an Object. Java can be easily extended since it is based on the Object model.\n\nPlatform independent: Unlike many other programming languages including C and C++, when Java is compiled, it is not compiled into platform specific machine, rather into platform independent byte code. This byte code is distributed over the web and interpreted by virtual Machine (JVM) on whichever platform it is being run.\n\nSimple:Java is designed to be easy to learn. If you understand the basic concept of OOP Java would be easy to master.\n\nSecure: With Java\'s secure feature it enables to develop virus-free, tamper-free systems. Authentication techniques are based on public-key encryption.\n\nArchitectural-neutral :Java compiler generates an architecture-neutral object file format which makes the compiled code to be executable on many processors, with the presence of Java runtime system.\n\nPortable:Being architectural-neutral and having no implementation dependent aspects of the specification makes Java portable. Compiler in Java is written in ANSI C with a clean portability boundary which is a POSIX subset.\n\nRobust:Java makes an effort to eliminate error prone situations by emphasizing mainly on compile time error checking and runtime checking.\n\nMultithreaded: With Java\'s multithreaded feature it is possible to write programs that can do many tasks simultaneously. This design feature allows developers to construct smoothly running interactive applications.\n\nInterpreted:Java byte code is translated on the fly to native machine instructions and is not stored anywhere. The development process is more rapid and analytical since the linking is an incremental and light weight process.\n\nHigh Performance: With the use of Just-In-Time compilers, Java enables high performance.\n\nDistributed:Java is designed for the distributed environment of the internet.\n\nDynamic: Java is considered to be more dynamic than C or C++ since it is designed to adapt to an evolving environment. Java programs can carry extensive amount of run-time information that can be used to verify and resolve accesses to objects on run-time."," Java is an Object-Oriented Language. As a language that has the Object Oriented feature, Java supports the following fundamental concepts:\n\nPolymorphism\nInheritance\nEncapsulation\nAbstraction\nClasses\nObjects\nInstance\nMethod\nMessage Parsing\nIn this chapter, we will look into the concepts Classes and Objects.\n\nObject - Objects have states and behaviors. Example: A dog has states - color, name, breed as well as behaviors -wagging, barking, eating. An object is an instance of a class.\n\nClass - A class can be defined as a template/blue print that describes the behaviors/states that object of its type support.\n\nObjects in Java:\nLet us now look deep into what are objects. If we consider the real-world we can find many objects around us, Cars, Dogs, Humans, etc. All these objects have a state and behavior.\n\nIf we consider a dog, then its state is - name, breed, color, and the behavior is - barking, wagging, running\n\nIf you compare the software object with a real world object, they have very similar characteristics.\n\nSoftware objects also have a state and behavior. A software object\'s state is stored in fields and behavior is shown via methods.\n\nSo in software development, methods operate on the internal state of an object and the object-to-object communication is done via methods.\n\nClasses in Java:\nA class is a blue print from which individual objects are created.\n\nA sample of a class is given below:\n\npublic class Dog{\n String breed;\n int age;\n String color;\n\n void barking(){\n }\n \n void hungry(){\n }\n \n void sleeping(){\n }\n}\nA class can contain any of the following variable types.\n\nLocal variables: Variables defined inside methods, constructors or blocks are called local variables. The variable will be declared and initialized within the method and the variable will be destroyed when the method has completed.\n\nInstance variables: Instance variables are variables within a class but outside any method. These variables are instantiated when the class is loaded. Instance variables can be accessed from inside any method, constructor or blocks of that particular class.\n\nClass variables: Class variables are variables declared with in a class, outside any method, with the static keyword.\n\nA class can have any number of methods to access the value of various kinds of methods. In the above example, barking(), hungry() and sleeping() are methods.\n\nBelow mentioned are some of the important topics that need to be discussed when looking into classes of the Java Language.\n\nConstructors:\nWhen discussing about classes, one of the most important sub topic would be constructors. Every class has a constructor. If we do not explicitly write a constructor for a class the Java compiler builds a default constructor for that class.\n\nEach time a new object is created, at least one constructor will be invoked. The main rule of constructors is that they should have the same name as the class. A class can have more than one constructor.\n\nExample of a constructor is given below:\n\npublic class Puppy{\n public puppy(){\n }\n\n public puppy(String name){\n // This constructor has one parameter, name.\n }\n}\nJava also supports Singleton Classes where you would be able to create only one instance of a class.\n\nCreating an Object:\nAs mentioned previously, a class provides the blueprints for objects. So basically an object is created from a class. In Java, the new key word is used to create new objects.\n\nThere are three steps when creating an object from a class:\n\nDeclaration: A variable declaration with a variable name with an object type.\n\nInstantiation: The \'new\' key word is used to create the object.\n\nInitialization: The \'new\' keyword is followed by a call to a constructor. This call initializes the new object.\n\nExample of creating an object is given below:\n\npublic class Puppy{\n\n public Puppy(String name){\n // This constructor has one parameter, name.\n System.out.println(\"Passed Name is :\" + name ); \n }\n public static void main(String []args){\n // Following statement would create an object myPuppy\n Puppy myPuppy = new Puppy( \"tommy\" );\n }\n}\nIf we compile and run the above program, then it would produce the following result:\n\nPassed Name is :tommy\nAccessing Instance Variables and Methods:\nInstance variables and methods are accessed via created objects. To access an instance variable the fully qualified path should be as follows:\n\n/* First create an object */\nObjectReference = new Constructor();\n\n/* Now call a variable as follows */\nObjectReference.variableName;\n\n/* Now you can call a class method as follows */\nObjectReference.MethodName();\nExample:\nThis example explains how to access instance variables and methods of a class:\n\npublic class Puppy{\n \n int puppyAge;\n\n public Puppy(String name){\n // This constructor has one parameter, name.\n System.out.println(\"Passed Name is :\" + name ); \n }\n public void setAge( int age ){\n puppyAge = age;\n }\n\n public int getAge( ){\n System.out.println(\"Puppy\'s age is :\" + puppyAge ); \n return puppyAge;\n }\n public static void main(String []args){\n /* Object creation */\n Puppy myPuppy = new Puppy( \"tommy\" );\n\n /* Call class method to set puppy\'s age */\n myPuppy.setAge( 2 );\n\n /* Call another class method to get puppy\'s age */\n myPuppy.getAge( );\n\n /* You can access instance variable as follows as well */\n System.out.println(\"Variable Value :\" + myPuppy.puppyAge ); \n }\n}\nIf we compile and run the above program, then it would produce the following result:\n\nPassed Name is :tommy\nPuppy\'s age is :2\nVariable Value :2\nSource file declaration rules:\nAs the last part of this section let\'s now look into the source file declaration rules. These rules are essential when declaring classes, import statements and package statements in a source file.\n\nThere can be only one public class per source file.\n\nA source file can have multiple non public classes.\n\nThe public class name should be the name of the source file as well which should be appended by .java at the end. For example : The class name is . public class Employee{} Then the source file should be as Employee.java.\n\nIf the class is defined inside a package, then the package statement should be the first statement in the source file.\n\nIf import statements are present then they must be written between the package statement and the class declaration. If there are no package statements then the import statement should be the first line in the source file.\n\nImport and package statements will imply to all the classes present in the source file. It is not possible to declare different import and/or package statements to different classes in the source file.\n\nClasses have several access levels and there are different types of classes; abstract classes, final classes, etc. I will be explaining about all these in the access modifiers chapter.\n\nApart from the above mentioned types of classes, Java also has some special classes called Inner classes and Anonymous classes.\n\nJava Package:\nIn simple, it is a way of categorizing the classes and interfaces. When developing applications in Java, hundreds of classes and interfaces will be written, therefore categorizing these classes is a must as well as makes life much easier.\n\nImport statements:\nIn Java if a fully qualified name, which includes the package and the class name, is given then the compiler can easily locate the source code or classes. Import statement is a way of giving the proper location for the compiler to find that particular class.\n\nFor example, the following line would ask compiler to load all the classes available in directory java_installation/java/io :\n\nimport java.io.*;\nA Simple Case Study:\nFor our case study, we will be creating two classes. They are Employee and EmployeeTest.\n\nFirst open notepad and add the following code. Remember this is the Employee class and the class is a public class. Now, save this source file with the name Employee.java.\n\nThe Employee class has four instance variables name, age, designation and salary. The class has one explicitly defined constructor, which takes a parameter.\n\nimport java.io.*;\npublic class Employee{\n String name;\n int age;\n String designation;\n double salary;\n\t\n // This is the constructor of the class Employee\n public Employee(String name){\n this.name = name;\n }\n // Assign the age of the Employee to the variable age.\n public void empAge(int empAge){\n age = empAge;\n }\n /* Assign the designation to the variable designation.*/\n public void empDesignation(String empDesig){\n designation = empDesig;\n }\n /* Assign the salary to the variable\tsalary.*/\n public void empSalary(double empSalary){\n salary = empSalary;\n }\n /* Print the Employee details */\n public void printEmployee(){\n System.out.println(\"Name:\"+ name );\n System.out.println(\"Age:\" + age );\n System.out.println(\"Designation:\" + designation );\n System.out.println(\"Salary:\" + salary);\n }\n}\nAs mentioned previously in this tutorial, processing starts from the main method. Therefore in-order for us to run this Employee class there should be main method and objects should be created. We will be creating a separate class for these tasks.\n\nGiven below is the EmployeeTest class, which creates two instances of the class Employee and invokes the methods for each object to assign values for each variable.\n\nSave the following code in EmployeeTest.java file\n\nimport java.io.*;\npublic class EmployeeTest{\n\n public static void main(String args[]){\n /* Create two objects using constructor */\n Employee empOne = new Employee(\"James Smith\");\n Employee empTwo = new Employee(\"Mary Anne\");\n\n // Invoking methods for each object created\n empOne.empAge(26);\n empOne.empDesignation(\"Senior Software Engineer\");\n empOne.empSalary(1000);\n empOne.printEmployee();\n\n empTwo.empAge(21);\n empTwo.empDesignation(\"Software Engineer\");\n empTwo.empSalary(500);\n empTwo.printEmployee();\n }\n}\nNow, compile both the classes and then run EmployeeTest to see the result as follows:\n\nC :> javac Employee.java\nC :> vi EmployeeTest.java\nC :> javac EmployeeTest.java\nC :> java EmployeeTest\nName:James Smith\nAge:26\nDesignation:Senior Software Engineer\nSalary:1000.0\nName:Mary Anne\nAge:21\nDesignation:Software Engineer\nSalary:500.0","In Java, all variables must be declared before they can be used. The basic form of a variable declaration is shown here:\n\ntype identifier [ = value][, identifier [= value] ...] ;\nThe type is one of Java\'s datatypes. The identifier is the name of the variable. To declare more than one variable of the specified type, use a comma-separated list.\n\nHere are several examples of variable declarations of various types. Note that some include an initialization.\n\nint a, b, c; // declares three ints, a, b, and c.\nint d = 3, e, f = 5; // declares three more ints, initializing\n // d and f.\nbyte z = 22; // initializes z.\ndouble pi = 3.14159; // declares an approximation of pi.\nchar x = \'x\'; // the variable x has the value \'x\'.\nThis chapter will explain various variable types available in Java Language. There are three kinds of variables in Java:\n\nLocal variables\n\nInstance variables\n\nClass/static variables\n\nLocal variables:\nLocal variables are declared in methods, constructors, or blocks.\n\nLocal variables are created when the method, constructor or block is entered and the variable will be destroyed once it exits the method, constructor or block.\n\nAccess modifiers cannot be used for local variables.\n\nLocal variables are visible only within the declared method, constructor or block.\n\nLocal variables are implemented at stack level internally.\n\nThere is no default value for local variables so local variables should be declared and an initial value should be assigned before the first use.\n\nExample:\nHere, age is a local variable. This is defined inside pupAge() method and its scope is limited to this method only.\n\npublic class Test{ \n public void pupAge(){\n int age = 0;\n age = age + 7;\n System.out.println(\"Puppy age is : \" + age);\n }\n \n public static void main(String args[]){\n Test test = new Test();\n test.pupAge();\n }\n}\nThis would produce the following result:\n\nPuppy age is: 7\nExample:\nFollowing example uses age without initializing it, so it would give an error at the time of compilation.\n\npublic class Test{ \n public void pupAge(){\n int age;\n age = age + 7;\n System.out.println(\"Puppy age is : \" + age);\n }\n \n public static void main(String args[]){\n Test test = new Test();\n test.pupAge();\n }\n}\nThis would produce the following error while compiling it:\n\nTest.java:4:variable number might not have been initialized\nage = age + 7;\n ^\n1 error\nInstance variables:\nInstance variables are declared in a class, but outside a method, constructor or any block.\n\nWhen a space is allocated for an object in the heap, a slot for each instance variable value is created.\n\nInstance variables are created when an object is created with the use of the keyword \'new\' and destroyed when the object is destroyed.\n\nInstance variables hold values that must be referenced by more than one method, constructor or block, or essential parts of an object\'s state that must be present throughout the class.\n\nInstance variables can be declared in class level before or after use.\n\nAccess modifiers can be given for instance variables.\n\nThe instance variables are visible for all methods, constructors and block in the class. Normally, it is recommended to make these variables private (access level). However visibility for subclasses can be given for these variables with the use of access modifiers.\n\nInstance variables have default values. For numbers the default value is 0, for Booleans it is false and for object references it is null. Values can be assigned during the declaration or within the constructor.\n\nInstance variables can be accessed directly by calling the variable name inside the class. However within static methods and different class ( when instance variables are given accessibility) should be called using the fully qualified name . ObjectReference.VariableName.\n\nExample:\nimport java.io.*;\n\npublic class Employee{\n // this instance variable is visible for any child class.\n public String name;\n \n // salary variable is visible in Employee class only.\n private double salary;\n \n // The name variable is assigned in the constructor. \n public Employee (String empName){\n name = empName;\n }\n\n // The salary variable is assigned a value.\n public void setSalary(double empSal){\n salary = empSal;\n }\n \n // This method prints the employee details.\n public void printEmp(){\n System.out.println(\"name : \" + name );\n System.out.println(\"salary :\" + salary);\n }\n\n public static void main(String args[]){\n Employee empOne = new Employee(\"Ransika\");\n empOne.setSalary(1000);\n empOne.printEmp();\n }\n}\nThis would produce the following result:\n\nname : Ransika\nsalary :1000.0\nClass/static variables:\nClass variables also known as static variables are declared with the static keyword in a class, but outside a method, constructor or a block.\n\nThere would only be one copy of each class variable per class, regardless of how many objects are created from it.\n\nStatic variables are rarely used other than being declared as constants. Constants are variables that are declared as public/private, final and static. Constant variables never change from their initial value.\n\nStatic variables are stored in static memory. It is rare to use static variables other than declared final and used as either public or private constants.\n\nStatic variables are created when the program starts and destroyed when the program stops.\n\nVisibility is similar to instance variables. However, most static variables are declared public since they must be available for users of the class.\n\nDefault values are same as instance variables. For numbers, the default value is 0; for Booleans, it is false; and for object references, it is null. Values can be assigned during the declaration or within the constructor. Additionally values can be assigned in special static initializer blocks.\n\nStatic variables can be accessed by calling with the class name . ClassName.VariableName.\n\nWhen declaring class variables as public static final, then variables names (constants) are all in upper case. If the static variables are not public and final the naming syntax is the same as instance and local variables.\n\nExample:\nimport java.io.*;\n\npublic class Employee{\n // salary variable is a private static variable\n private static double salary;\n\n // DEPARTMENT is a constant\n public static final String DEPARTMENT = \"Development \";\n\n public static void main(String args[]){\n salary = 1000;\n System.out.println(DEPARTMENT+\"average salary:\"+salary);\n }\n}\nThis would produce the following result:\n\nDevelopment average salary:1000","There may be a situation when we need to execute a block of code several number of times, and is often referred to as a loop.\n\nJava has very flexible three looping mechanisms. You can use one of the following three loops:\n\nwhile Loop\n\ndo...while Loop\n\nfor Loop\n\nAs of Java 5, the enhanced for loop was introduced. This is mainly used for Arrays.\n\nThe while Loop:\nA while loop is a control structure that allows you to repeat a task a certain number of times.\n\nSyntax:\nThe syntax of a while loop is:\n\nwhile(Boolean_expression)\n{\n //Statements\n}\nWhen executing, if the boolean_expression result is true, then the actions inside the loop will be executed. This will continue as long as the expression result is true.\n\nHere, key point of the while loop is that the loop might not ever run. When the expression is tested and the result is false, the loop body will be skipped and the first statement after the while loop will be executed.\n\nExample:\npublic class Test {\n\n public static void main(String args[]) {\n int x = 10;\n\n while( x < 20 ) {\n System.out.print(\"value of x : \" + x );\n x++;\n System.out.print(\"\\n\");\n }\n }\n}\nThis would produce the following result:\n\nvalue of x : 10\nvalue of x : 11\nvalue of x : 12\nvalue of x : 13\nvalue of x : 14\nvalue of x : 15\nvalue of x : 16\nvalue of x : 17\nvalue of x : 18\nvalue of x : 19\nThe do...while Loop:\nA do...while loop is similar to a while loop, except that a do...while loop is guaranteed to execute at least one time.\n\nSyntax:\nThe syntax of a do...while loop is:\n\ndo\n{\n //Statements\n}while(Boolean_expression);\nNotice that the Boolean expression appears at the end of the loop, so the statements in the loop execute once before the Boolean is tested.\n\nIf the Boolean expression is true, the flow of control jumps back up to do, and the statements in the loop execute again. This process repeats until the Boolean expression is false.\n\nExample:\npublic class Test {\n\n public static void main(String args[]){\n int x = 10;\n\n do{\n System.out.print(\"value of x : \" + x );\n x++;\n System.out.print(\"\\n\");\n }while( x < 20 );\n }\n}\nThis would produce the following result:\n\nvalue of x : 10\nvalue of x : 11\nvalue of x : 12\nvalue of x : 13\nvalue of x : 14\nvalue of x : 15\nvalue of x : 16\nvalue of x : 17\nvalue of x : 18\nvalue of x : 19\nThe for Loop:\nA for loop is a repetition control structure that allows you to efficiently write a loop that needs to execute a specific number of times.\n\nA for loop is useful when you know how many times a task is to be repeated.\n\nSyntax:\nThe syntax of a for loop is:\n\nfor(initialization; Boolean_expression; update)\n{\n //Statements\n}\nHere is the flow of control in a for loop:\n\nThe initialization step is executed first, and only once. This step allows you to declare and initialize any loop control variables. You are not required to put a statement here, as long as a semicolon appears.\n\nNext, the Boolean expression is evaluated. If it is true, the body of the loop is executed. If it is false, the body of the loop does not execute and flow of control jumps to the next statement past the for loop.\n\nAfter the body of the for loop executes, the flow of control jumps back up to the update statement. This statement allows you to update any loop control variables. This statement can be left blank, as long as a semicolon appears after the Boolean expression.\n\nThe Boolean expression is now evaluated again. If it is true, the loop executes and the process repeats itself (body of loop, then update step, then Boolean expression). After the Boolean expression is false, the for loop terminates.\n\nExample:\npublic class Test {\n\n public static void main(String args[]) {\n\n for(int x = 10; x < 20; x = x+1) {\n System.out.print(\"value of x : \" + x );\n System.out.print(\"\\n\");\n }\n }\n}\nThis would produce the following result:\n\nvalue of x : 10\nvalue of x : 11\nvalue of x : 12\nvalue of x : 13\nvalue of x : 14\nvalue of x : 15\nvalue of x : 16\nvalue of x : 17\nvalue of x : 18\nvalue of x : 19\nEnhanced for loop in Java:\nAs of Java 5, the enhanced for loop was introduced. This is mainly used for Arrays.\n\nSyntax:\nThe syntax of enhanced for loop is:\n\nfor(declaration : expression)\n{\n //Statements\n}\nDeclaration: The newly declared block variable, which is of a type compatible with the elements of the array you are accessing. The variable will be available within the for block and its value would be the same as the current array element.\n\nExpression: This evaluates to the array you need to loop through. The expression can be an array variable or method call that returns an array.\n\nExample:\npublic class Test {\n\n public static void main(String args[]){\n int [] numbers = {10, 20, 30, 40, 50};\n\n for(int x : numbers ){\n System.out.print( x );\n System.out.print(\",\");\n }\n System.out.print(\"\\n\");\n String [] names ={\"James\", \"Larry\", \"Tom\", \"Lacy\"};\n for( String name : names ) {\n System.out.print( name );\n System.out.print(\",\");\n }\n }\n}\nThis would produce the following result:\n\n10,20,30,40,50,\nJames,Larry,Tom,Lacy,\nThe break Keyword:\nThe break keyword is used to stop the entire loop. The break keyword must be used inside any loop or a switch statement.\n\nThe break keyword will stop the execution of the innermost loop and start executing the next line of code after the block.\n\nSyntax:\nThe syntax of a break is a single statement inside any loop:\n\nbreak;\nExample:\npublic class Test {\n\n public static void main(String args[]) {\n int [] numbers = {10, 20, 30, 40, 50};\n\n for(int x : numbers ) {\n if( x == 30 ) {\n\t break;\n }\n System.out.print( x );\n System.out.print(\"\\n\");\n }\n }\n}\nThis would produce the following result:\n\n10\n20\nThe continue Keyword:\nThe continue keyword can be used in any of the loop control structures. It causes the loop to immediately jump to the next iteration of the loop.\n\nIn a for loop, the continue keyword causes flow of control to immediately jump to the update statement.\n\nIn a while loop or do/while loop, flow of control immediately jumps to the Boolean expression.\n\nSyntax:\nThe syntax of a continue is a single statement inside any loop:\n\ncontinue;\nExample:\npublic class Test {\n\n public static void main(String args[]) {\n int [] numbers = {10, 20, 30, 40, 50};\n\n for(int x : numbers ) {\n if( x == 30 ) {\n\t continue;\n }\n System.out.print( x );\n System.out.print(\"\\n\");\n }\n }\n}\nThis would produce the following result:\n\n10\n20\n40\n50","Normally, when we work with Numbers, we use primitive data types such as byte, int, long, double, etc.\n\nExample:\nint i = 5000;\nfloat gpa = 13.65;\nbyte mask = 0xaf;\nHowever, in development, we come across situations where we need to use objects instead of primitive data types. In-order to achieve this Java provides wrapper classes for each primitive data type.\n\nAll the wrapper classes (Integer, Long, Byte, Double, Float, Short) are subclasses of the abstract class Number.\n\nNumber Subclasses\nThis wrapping is taken care of by the compiler, the process is called boxing. So when a primitive is used when an object is required, the compiler boxes the primitive type in its wrapper class. Similarly, the compiler unboxes the object to a primitive as well. The Number is part of the java.lang package.\n\nHere is an example of boxing and unboxing:\n\npublic class Test{\n\n public static void main(String args[]){\n Integer x = 5; // boxes int to an Integer object\n x = x + 10; // unboxes the Integer to a int\n System.out.println(x); \n }\n}\nThis would produce the following result:\n\n15\nWhen x is assigned integer values, the compiler boxes the integer because x is integer objects. Later, x is unboxed so that they can be added as integers.\n\nNumber Methods:\nHere is the list of the instance methods that all the subclasses of the Number class implement:\n\nSN\tMethods with Description\n1\txxxValue()\nConverts the value of this Number object to the xxx data type and returned it.\n2\tcompareTo()\nCompares this Number object to the argument.\n3\tequals()\nDetermines whether this number object is equal to the argument.\n4\tvalueOf()\nReturns an Integer object holding the value of the specified primitive.\n5\ttoString()\nReturns a String object representing the value of specified int or Integer.\n6\tparseInt()\nThis method is used to get the primitive data type of a certain String.\n7\tabs()\nReturns the absolute value of the argument.\n8\tceil()\nReturns the smallest integer that is greater than or equal to the argument. Returned as a double.\n9\tfloor()\nReturns the largest integer that is less than or equal to the argument. Returned as a double.\n10\trint()\nReturns the integer that is closest in value to the argument. Returned as a double.\n11\tround()\nReturns the closest long or int, as indicated by the method\'s return type, to the argument.\n12\tmin()\nReturns the smaller of the two arguments.\n13\tmax()\nReturns the larger of the two arguments.\n14\texp()\nReturns the base of the natural logarithms, e, to the power of the argument.\n15\tlog()\nReturns the natural logarithm of the argument.\n16\tpow()\nReturns the value of the first argument raised to the power of the second argument.\n17\tsqrt()\nReturns the square root of the argument.\n18\tsin()\nReturns the sine of the specified double value.\n19\tcos()\nReturns the cosine of the specified double value.\n20\ttan()\nReturns the tangent of the specified double value.\n21\tasin()\nReturns the arcsine of the specified double value.\n22\tacos()\nReturns the arccosine of the specified double value.\n23\tatan()\nReturns the arctangent of the specified double value.\n24\tatan2()\nConverts rectangular coordinates (x, y) to polar coordinate (r, theta) and returns theta.\n25\ttoDegrees()\nConverts the argument to degrees\n26\ttoRadians()\nConverts the argument to radians.\n27\trandom()\nReturns a random number.","There are two types of decision making statements in Java. They are:\n\nif statements\n\nswitch statements\n\nThe if Statement:\nAn if statement consists of a Boolean expression followed by one or more statements.\n\nSyntax:\nThe syntax of an if statement is:\n\nif(Boolean_expression)\n{\n //Statements will execute if the Boolean expression is true\n}\nIf the Boolean expression evaluates to true then the block of code inside the if statement will be executed. If not the first set of code after the end of the if statement (after the closing curly brace) will be executed.\n\nExample:\npublic class Test {\n\n public static void main(String args[]){\n int x = 10;\n\n if( x < 20 ){\n System.out.print(\"This is if statement\");\n }\n }\n}\nThis would produce the following result:\n\nThis is if statement\nThe if...else Statement:\nAn if statement can be followed by an optional else statement, which executes when the Boolean expression is false.\n\nSyntax:\nThe syntax of an if...else is:\n\nif(Boolean_expression){\n //Executes when the Boolean expression is true\n}else{\n //Executes when the Boolean expression is false\n}\nExample:\npublic class Test {\n\n public static void main(String args[]){\n int x = 30;\n\n if( x < 20 ){\n System.out.print(\"This is if statement\");\n }else{\n System.out.print(\"This is else statement\");\n }\n }\n}\nThis would produce the following result:\n\nThis is else statement\nThe if...else if...else Statement:\nAn if statement can be followed by an optional else if...else statement, which is very useful to test various conditions using single if...else if statement.\n\nWhen using if , else if , else statements there are few points to keep in mind.\n\nAn if can have zero or one else\'s and it must come after any else if\'s.\n\nAn if can have zero to many else if\'s and they must come before the else.\n\nOnce an else if succeeds, none of the remaining else if\'s or else\'s will be tested.\n\nSyntax:\nThe syntax of an if...else is:\n\nif(Boolean_expression 1){\n //Executes when the Boolean expression 1 is true\n}else if(Boolean_expression 2){\n //Executes when the Boolean expression 2 is true\n}else if(Boolean_expression 3){\n //Executes when the Boolean expression 3 is true\n}else {\n //Executes when the none of the above condition is true.\n}\nExample:\npublic class Test {\n\n public static void main(String args[]){\n int x = 30;\n\n if( x == 10 ){\n System.out.print(\"Value of X is 10\");\n }else if( x == 20 ){\n System.out.print(\"Value of X is 20\");\n }else if( x == 30 ){\n System.out.print(\"Value of X is 30\");\n }else{\n System.out.print(\"This is else statement\");\n }\n }\n}\nThis would produce the following result:\n\nValue of X is 30\nNested if...else Statement:\nIt is always legal to nest if-else statements which means you can use one if or else if statement inside another if or else if statement.\n\nSyntax:\nThe syntax for a nested if...else is as follows:\n\nif(Boolean_expression 1){\n //Executes when the Boolean expression 1 is true\n if(Boolean_expression 2){\n //Executes when the Boolean expression 2 is true\n }\n}\nYou can nest else if...else in the similar way as we have nested if statement.\n\nExample:\npublic class Test {\n\n public static void main(String args[]){\n int x = 30;\n int y = 10;\n\n if( x == 30 ){\n if( y == 10 ){\n System.out.print(\"X = 30 and Y = 10\");\n }\n }\n }\n}\nThis would produce the following result:\n\nX = 30 and Y = 10\nThe switch Statement:\nA switch statement allows a variable to be tested for equality against a list of values. Each value is called a case, and the variable being switched on is checked for each case.\n\nSyntax:\nThe syntax of enhanced for loop is:\n\nswitch(expression){\n case value :\n //Statements\n break; //optional\n case value :\n //Statements\n break; //optional\n //You can have any number of case statements.\n default : //Optional\n //Statements\n}\nThe following rules apply to a switch statement:\n\nThe variable used in a switch statement can only be a byte, short, int, or char.\n\nYou can have any number of case statements within a switch. Each case is followed by the value to be compared to and a colon.\n\nThe value for a case must be the same data type as the variable in the switch and it must be a constant or a literal.\n\nWhen the variable being switched on is equal to a case, the statements following that case will execute until a break statement is reached.\n\nWhen a break statement is reached, the switch terminates, and the flow of control jumps to the next line following the switch statement.\n\nNot every case needs to contain a break. If no break appears, the flow of control will fall through to subsequent cases until a break is reached.\n\nA switch statement can have an optional default case, which must appear at the end of the switch. The default case can be used for performing a task when none of the cases is true. No break is needed in the default case.\n\nExample:\npublic class Test {\n\n public static void main(String args[]){\n //char grade = args[0].charAt(0);\n char grade = \'C\';\n\n switch(grade)\n {\n case \'A\' :\n System.out.println(\"Excellent!\"); \n break;\n case \'B\' :\n case \'C\' :\n System.out.println(\"Well done\");\n break;\n case \'D\' :\n System.out.println(\"You passed\");\n case \'F\' :\n System.out.println(\"Better try again\");\n break;\n default :\n System.out.println(\"Invalid grade\");\n }\n System.out.println(\"Your grade is \" + grade);\n }\n}\nCompile and run above program using various command line arguments. This would produce the following result:\n\n$ java Test\nWell done\nYour grade is a C\n$","Strings, which are widely used in Java programming, are a sequence of characters. In the Java programming language, strings are objects.\n\nThe Java platform provides the String class to create and manipulate strings.\n\nCreating Strings:\nThe most direct way to create a string is to write:\n\nString greeting = \"Hello world!\";\nWhenever it encounters a string literal in your code, the compiler creates a String object with its value in this case, \"Hello world!\'.\n\nAs with any other object, you can create String objects by using the new keyword and a constructor. The String class has eleven constructors that allow you to provide the initial value of the string using different sources, such as an array of characters.\n\npublic class StringDemo{\n\n public static void main(String args[]){\n char[] helloArray = { \'h\', \'e\', \'l\', \'l\', \'o\', \'.\'};\n String helloString = new String(helloArray); \n System.out.println( helloString );\n }\n}\nThis would produce the following result:\n\nhello.\nNote: The String class is immutable, so that once it is created a String object cannot be changed. If there is a necessity to make a lot of modifications to Strings of characters, then you should use String Buffer & String Builder Classes.\n\nString Length:\nMethods used to obtain information about an object are known as accessor methods. One accessor method that you can use with strings is the length() method, which returns the number of characters contained in the string object.\n\nAfter the following two lines of code have been executed, len equals 17:\n\npublic class StringDemo {\n\n public static void main(String args[]) {\n String palindrome = \"Dot saw I was Tod\";\n int len = palindrome.length();\n System.out.println( \"String Length is : \" + len );\n }\n}\nThis would produce the following result:\n\nString Length is : 17\nConcatenating Strings:\nThe String class includes a method for concatenating two strings:\n\nstring1.concat(string2);\nThis returns a new string that is string1 with string2 added to it at the end. You can also use the concat() method with string literals, as in:\n\n\"My name is \".concat(\"Zara\");\nStrings are more commonly concatenated with the + operator, as in:\n\n\"Hello,\" + \" world\" + \"!\"\nwhich results in:\n\n\"Hello, world!\"\nLet us look at the following example:\n\npublic class StringDemo {\n\n public static void main(String args[]) {\n String string1 = \"saw I was \";\n System.out.println(\"Dot \" + string1 + \"Tod\");\n }\n}\nThis would produce the following result:\n\nDot saw I was Tod\nCreating Format Strings:\nYou have printf() and format() methods to print output with formatted numbers. The String class has an equivalent class method, format(), that returns a String object rather than a PrintStream object.\n\nUsing String\'s static format() method allows you to create a formatted string that you can reuse, as opposed to a one-time print statement. For example, instead of:\n\nSystem.out.printf(\"The value of the float variable is \" +\n \"%f, while the value of the integer \" +\n \"variable is %d, and the string \" +\n \"is %s\", floatVar, intVar, stringVar);\nyou can write:\n\nString fs;\nfs = String.format(\"The value of the float variable is \" +\n \"%f, while the value of the integer \" +\n \"variable is %d, and the string \" +\n \"is %s\", floatVar, intVar, stringVar);\nSystem.out.println(fs);\nString Methods:\nHere is the list of methods supported by String class:\n\nSN\tMethods with Description\n1\tchar charAt(int index) \nReturns the character at the specified index.\n2\tint compareTo(Object o) \nCompares this String to another Object.\n3\tint compareTo(String anotherString)\nCompares two strings lexicographically.\n4\tint compareToIgnoreCase(String str) \nCompares two strings lexicographically, ignoring case differences.\n5\tString concat(String str)\nConcatenates the specified string to the end of this string.\n6\tboolean contentEquals(StringBuffer sb) \nReturns true if and only if this String represents the same sequence of characters as the specified StringBuffer.\n7\tstatic String copyValueOf(char[] data) \nReturns a String that represents the character sequence in the array specified.\n8\tstatic String copyValueOf(char[] data, int offset, int count)\nReturns a String that represents the character sequence in the array specified.\n9\tboolean endsWith(String suffix) \nTests if this string ends with the specified suffix.\n10\tboolean equals(Object anObject)\nCompares this string to the specified object.\n11\tboolean equalsIgnoreCase(String anotherString)\nCompares this String to another String, ignoring case considerations.\n12\tbyte getBytes() \nEncodes this String into a sequence of bytes using the platform\'s default charset, storing the result into a new byte array.\n13\tbyte[] getBytes(String charsetName\nEncodes this String into a sequence of bytes using the named charset, storing the result into a new byte array.\n14\tvoid getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin)\nCopies characters from this string into the destination character array.\n15\tint hashCode()\nReturns a hash code for this string.\n16\tint indexOf(int ch) \nReturns the index within this string of the first occurrence of the specified character.\n17\tint indexOf(int ch, int fromIndex) \nReturns the index within this string of the first occurrence of the specified character, starting the search at the specified index.\n18\tint indexOf(String str)\nReturns the index within this string of the first occurrence of the specified substring.\n19\tint indexOf(String str, int fromIndex)\nReturns the index within this string of the first occurrence of the specified substring, starting at the specified index.\n20\tString intern()\nReturns a canonical representation for the string object.\n21\tint lastIndexOf(int ch) \nReturns the index within this string of the last occurrence of the specified character.\n22\tint lastIndexOf(int ch, int fromIndex) \nReturns the index within this string of the last occurrence of the specified character, searching backward starting at the specified index.\n23\tint lastIndexOf(String str)\nReturns the index within this string of the rightmost occurrence of the specified substring.\n24\tint lastIndexOf(String str, int fromIndex) \nReturns the index within this string of the last occurrence of the specified substring, searching backward starting at the specified index.\n25\tint length() \nReturns the length of this string.\n26\tboolean matches(String regex)\nTells whether or not this string matches the given regular expression.\n27\tboolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) \nTests if two string regions are equal.\n28\tboolean regionMatches(int toffset, String other, int ooffset, int len)\nTests if two string regions are equal.\n29\tString replace(char oldChar, char newChar)\nReturns a new string resulting from replacing all occurrences of oldChar in this string with newChar.\n30\tString replaceAll(String regex, String replacement\nReplaces each substring of this string that matches the given regular expression with the given replacement.\n31\tString replaceFirst(String regex, String replacement) \nReplaces the first substring of this string that matches the given regular expression with the given replacement.\n32\tString[] split(String regex) \nSplits this string around matches of the given regular expression.\n33\tString[] split(String regex, int limit) \nSplits this string around matches of the given regular expression.\n34\tboolean startsWith(String prefix)\nTests if this string starts with the specified prefix.\n35\tboolean startsWith(String prefix, int toffset)\nTests if this string starts with the specified prefix beginning a specified index.\n36\tCharSequence subSequence(int beginIndex, int endIndex)\nReturns a new character sequence that is a subsequence of this sequence.\n37\tString substring(int beginIndex)\nReturns a new string that is a substring of this string.\n38\tString substring(int beginIndex, int endIndex)\nReturns a new string that is a substring of this string.\n39\tchar[] toCharArray() \nConverts this string to a new character array.\n40\tString toLowerCase()\nConverts all of the characters in this String to lower case using the rules of the default locale.\n41\tString toLowerCase(Locale locale)\nConverts all of the characters in this String to lower case using the rules of the given Locale.\n42\tString toString()\nThis object (which is already a string!) is itself returned.\n43\tString toUpperCase() \nConverts all of the characters in this String to upper case using the rules of the default locale.\n44\tString toUpperCase(Locale locale) \nConverts all of the characters in this String to upper case using the rules of the given Locale.\n45\tString trim() \nReturns a copy of the string, with leading and trailing whitespace omitted.\n46\tstatic String valueOf(primitive data type x) \nReturns the string representation of the passed data type argument.","A Java method is a collection of statements that are grouped together to perform an operation. When you call the System.out.println method, for example, the system actually executes several statements in order to display a message on the console.\n\nNow you will learn how to create your own methods with or without return values, invoke a method with or without parameters, overload methods using the same names, and apply method abstraction in the program design.\n\nCreating a Method:\nIn general, a method has the following syntax:\n\nmodifier returnValueType methodName(list of parameters) {\n // Method body;\n}\nA method definition consists of a method header and a method body. Here are all the parts of a method:\n\nModifiers: The modifier, which is optional, tells the compiler how to call the method. This defines the access type of the method.\n\nReturn Type: A method may return a value. The returnValueType is the data type of the value the method returns. Some methods perform the desired operations without returning a value. In this case, the returnValueType is the keyword void.\n\nMethod Name: This is the actual name of the method. The method name and the parameter list together constitute the method signature.\n\nParameters: A parameter is like a placeholder. When a method is invoked, you pass a value to the parameter. This value is referred to as actual parameter or argument. The parameter list refers to the type, order, and number of the parameters of a method. Parameters are optional; that is, a method may contain no parameters.\n\nMethod Body: The method body contains a collection of statements that define what the method does.\n\nJava Methods\nNote: In certain other languages, methods are referred to as procedures and functions. A method with a nonvoid return value type is called a function; a method with a void return value type is called a procedure.\n\nExample:\nHere is the source code of the above defined method called max(). This method takes two parameters num1 and num2 and returns the maximum between the two:\n\n/** Return the max between two numbers */\npublic static int max(int num1, int num2) {\n int result;\n if (num1 > num2)\n result = num1;\n else\n result = num2;\n\n return result; \n}\nCalling a Method:\nIn creating a method, you give a definition of what the method is to do. To use a method, you have to call or invoke it. There are two ways to call a method; the choice is based on whether the method returns a value or not.\n\nWhen a program calls a method, program control is transferred to the called method. A called method returns control to the caller when its return statement is executed or when its method-ending closing brace is reached.\n\nIf the method returns a value, a call to the method is usually treated as a value. For example:\n\nint larger = max(30, 40);\nIf the method returns void, a call to the method must be a statement. For example, the method println returns void. The following call is a statement:\n\nSystem.out.println(\"Welcome to Java!\");\nExample:\nFollowing is the example to demonstrate how to define a method and how to call it:\n\npublic class TestMax {\n /** Main method */\n public static void main(String[] args) {\n int i = 5;\n int j = 2;\n int k = max(i, j);\n System.out.println(\"The maximum between \" + i +\n \" and \" + j + \" is \" + k);\n }\n\n /** Return the max between two numbers */\n public static int max(int num1, int num2) {\n int result;\n if (num1 > num2)\n result = num1;\n else\n result = num2;\n\n return result; \n }\n}\nThis would produce the following result:\n\nThe maximum between 5 and 2 is 5\nThis program contains the main method and the max method. The main method is just like any other method except that it is invoked by the JVM.\n\nThe main method\'s header is always the same, like the one in this example, with the modifiers public and static, return value type void, method name main, and a parameter of the String[] type. String[] indicates that the parameter is an array of String.\n\nThe void Keyword:\nThis section shows how to declare and invoke a void method. Following example gives a program that declares a method named printGrade and invokes it to print the grade for a given score.\n\nExample:\npublic class TestVoidMethod {\n\n public static void main(String[] args) {\n printGrade(78.5);\n }\n\n public static void printGrade(double score) {\n if (score >= 90.0) {\n System.out.println(\'A\');\n }\n else if (score >= 80.0) {\n System.out.println(\'B\');\n }\n else if (score >= 70.0) {\n System.out.println(\'C\');\n }\n else if (score >= 60.0) {\n System.out.println(\'D\');\n }\n else {\n System.out.println(\'F\');\n }\n }\n}\nThis would produce the following result:\n\nC\nHere the printGrade method is a void method. It does not return any value. A call to a void method must be a statement. So, it is invoked as a statement in line 3 in the main method. This statement is like any Java statement terminated with a semicolon.\n\nPassing Parameters by Values:\nWhen calling a method, you need to provide arguments, which must be given in the same order as their respective parameters in the method specification. This is known as parameter order association.\n\nFor example, the following method prints a message n times:\n\npublic static void nPrintln(String message, int n) {\n for (int i = 0; i < n; i++)\n System.out.println(message);\n}\nHere, you can use nPrintln(\"Hello\", 3) to print \"Hello\" three times. The nPrintln(\"Hello\", 3) statement passes the actual string parameter, \"Hello\", to the parameter, message; passes 3 to n; and prints \"Hello\" three times. However, the statement nPrintln(3, \"Hello\") would be wrong.\n\nWhen you invoke a method with a parameter, the value of the argument is passed to the parameter. This is referred to as pass-by-value. If the argument is a variable rather than a literal value, the value of the variable is passed to the parameter. The variable is not affected, regardless of the changes made to the parameter inside the method.\n\nFor simplicity, Java programmers often say passing an argument x to a parameter y, which actually means passing the value of x to y.\n\nExample:\nFollowing is a program that demonstrates the effect of passing by value. The program creates a method for swapping two variables. The swap method is invoked by passing two arguments. Interestingly, the values of the arguments are not changed after the method is invoked.\n\npublic class TestPassByValue {\n\n public static void main(String[] args) {\n int num1 = 1;\n int num2 = 2;\n\n System.out.println(\"Before swap method, num1 is \" +\n num1 + \" and num2 is \" + num2);\n\n // Invoke the swap method\n swap(num1, num2);\n System.out.println(\"After swap method, num1 is \" +\n num1 + \" and num2 is \" + num2);\n }\n /** Method to swap two variables */\n public static void swap(int n1, int n2) {\n System.out.println(\"\\tInside the swap method\");\n System.out.println(\"\\t\\tBefore swapping n1 is \" + n1\n + \" n2 is \" + n2);\n // Swap n1 with n2\n int temp = n1;\n n1 = n2;\n n2 = temp;\n\n System.out.println(\"\\t\\tAfter swapping n1 is \" + n1\n + \" n2 is \" + n2);\n }\n}\nThis would produce the following result:\n\nBefore swap method, num1 is 1 and num2 is 2\n Inside the swap method\n Before swapping n1 is 1 n2 is 2\n After swapping n1 is 2 n2 is 1\nAfter swap method, num1 is 1 and num2 is 2\nOverloading Methods:\nThe max method that was used earlier works only with the int data type. But what if you need to find which of two floating-point numbers has the maximum value? The solution is to create another method with the same name but different parameters, as shown in the following code:\n\npublic static double max(double num1, double num2) {\n if (num1 > num2)\n return num1;\n else\n return num2;\n}\nIf you call max with int parameters, the max method that expects int parameters will be invoked; if you call max with double parameters, the max method that expects double parameters will be invoked. This is referred to as method overloading; that is, two methods have the same name but different parameter lists within one class.\n\nThe Java compiler determines which method is used based on the method signature. Overloading methods can make programs clearer and more readable. Methods that perform closely related tasks should be given the same name.\n\nOverloaded methods must have different parameter lists. You cannot overload methods based on different modifiers or return types. Sometimes there are two or more possible matches for an invocation of a method due to similar method signature, so the compiler cannot determine the most specific match. This is referred to as ambiguous invocation.\n\nThe Scope of Variables:\nThe scope of a variable is the part of the program where the variable can be referenced. A variable defined inside a method is referred to as a local variable.\n\nThe scope of a local variable starts from its declaration and continues to the end of the block that contains the variable. A local variable must be declared before it can be used.\n\nA parameter is actually a local variable. The scope of a method parameter covers the entire method.\n\nA variable declared in the initial action part of a for loop header has its scope in the entire loop. But a variable declared inside a for loop body has its scope limited in the loop body from its declaration to the end of the block that contains the variable as shown below:\n\nJava Variable Scope\nYou can declare a local variable with the same name multiple times in different non-nesting blocks in a method, but you cannot declare a local variable twice in nested blocks.\n\nUsing Command-Line Arguments:\nSometimes you will want to pass information into a program when you run it. This is accomplished by passing command-line arguments to main( ).\n\nA command-line argument is the information that directly follows the program\'s name on the command line when it is executed. To access the command-line arguments inside a Java program is quite easy.they are stored as strings in the String array passed to main( ).\n\nExample:\nThe following program displays all of the command-line arguments that it is called with:\n\npublic class CommandLine {\n\n public static void main(String args[]){ \n for(int i=0; i<args.length; i++){\n System.out.println(\"args[\" + i + \"]: \" +\n args[i]);\n }\n }\n}\nTry executing this program as shown here:\n\njava CommandLine this is a command line 200 -100\nThis would produce the following result:\n\nargs[0]: this\nargs[1]: is\nargs[2]: a\nargs[3]: command\nargs[4]: line\nargs[5]: 200\nargs[6]: -100\nThe Constructors:\nA constructor initializes an object when it is created. It has the same name as its class and is syntactically similar to a method. However, constructors have no explicit return type.\n\nTypically, you will use a constructor to give initial values to the instance variables defined by the class, or to perform any other startup procedures required to create a fully formed object.\n\nAll classes have constructors, whether you define one or not, because Java automatically provides a default constructor that initializes all member variables to zero. However, once you define your own constructor, the default constructor is no longer used.\n\nExample:\nHere is a simple example that uses a constructor:\n\n// A simple constructor.\nclass MyClass {\n int x;\n \n // Following is the constructor\n MyClass() {\n x = 10;\n }\n}\nYou would call constructor to initialize objects as follows:\n\npublic class ConsDemo {\n\n public static void main(String args[]) {\n MyClass t1 = new MyClass();\n MyClass t2 = new MyClass();\n System.out.println(t1.x + \" \" + t2.x);\n }\n}\nMost often, you will need a constructor that accepts one or more parameters. Parameters are added to a constructor in the same way that they are added to a method, just declare them inside the parentheses after the constructor\'s name.\n\nExample:\nHere is a simple example that uses a constructor:\n\n// A simple constructor.\nclass MyClass {\n int x;\n \n // Following is the constructor\n MyClass(int i ) {\n x = i;\n }\n}\nYou would call constructor to initialize objects as follows:\n\npublic class ConsDemo {\n\n public static void main(String args[]) {\n MyClass t1 = new MyClass( 10 );\n MyClass t2 = new MyClass( 20 );\n System.out.println(t1.x + \" \" + t2.x);\n }\n}\nThis would produce the following result:\n\n10 20\nVariable Arguments(var-args):\nJDK 1.5 enables you to pass a variable number of arguments of the same type to a method. The parameter in the method is declared as follows:\n\ntypeName... parameterName\nIn the method declaration, you specify the type followed by an ellipsis (...) Only one variable-length parameter may be specified in a method, and this parameter must be the last parameter. Any regular parameters must precede it.\n\nExample:\npublic class VarargsDemo {\n\n public static void main(String args[]) {\n // Call method with variable args \n\t printMax(34, 3, 3, 2, 56.5);\n printMax(new double[]{1, 2, 3});\n }\n\n public static void printMax( double... numbers) {\n if (numbers.length == 0) {\n System.out.println(\"No argument passed\");\n return;\n }\n\n double result = numbers[0];\n\n for (int i = 1; i < numbers.length; i++)\n if (numbers[i] > result)\n result = numbers[i];\n System.out.println(\"The max value is \" + result);\n }\n}\nThis would produce the following result:\n\nThe max value is 56.5\nThe max value is 3.0\nThe finalize( ) Method:\nIt is possible to define a method that will be called just before an object\'s final destruction by the garbage collector. This method is called finalize( ), and it can be used to ensure that an object terminates cleanly.\n\nFor example, you might use finalize( ) to make sure that an open file owned by that object is closed.\n\nTo add a finalizer to a class, you simply define the finalize( ) method. The Java runtime calls that method whenever it is about to recycle an object of that class.\n\nInside the finalize( ) method, you will specify those actions that must be performed before an object is destroyed.\n\nThe finalize( ) method has this general form:\n\nprotected void finalize( )\n{\n // finalization code here\n}\nHere, the keyword protected is a specifier that prevents access to finalize( ) by code defined outside its class.\n\nThis means that you cannot know when or even if finalize( ) will be executed. For example, if your program ends before garbage collection occurs, finalize( ) will not execute.","The java.io package contains nearly every class you might ever need to perform input and output (I/O) in Java. All these streams represent an input source and an output destination. The stream in the java.io package supports many data such as primitives, Object, localized characters, etc.\n\nA stream can be defined as a sequence of data. The InputStream is used to read data from a source and the OutputStream is used for writing data to a destination.\n\nJava does provide strong, flexible support for I/O as it relates to files and networks but this tutorial covers very basic functionality related to streams and I/O. We would see most commonly used example one by one:\n\nReading Console Input:\nJava input console is accomplished by reading from System.in. To obtain a character-based stream that is attached to the console, you wrap System.in in a BufferedReader object, to create a character stream. Here is most common syntax to obtain BufferedReader:\n\nBufferedReader br = new BufferedReader(new \n InputStreamReader(System.in));\nOnce BufferedReader is obtained, we can use read( ) method to reach a character or readLine( ) method to read a string from the console.\n\nReading Characters from Console:\nTo read a character from a BufferedReader, we would read( ) method whose sytax is as follows:\n\nint read( ) throws IOException\nEach time that read( ) is called, it reads a character from the input stream and returns it as an integer value. It returns .1 when the end of the stream is encountered. As you can see, it can throw an IOException.\n\nThe following program demonstrates read( ) by reading characters from the console until the user types a \"q\":\n\n// Use a BufferedReader to read characters from the console.\n\nimport java.io.*;\n\npublic class BRRead {\n public static void main(String args[]) throws IOException\n {\n char c;\n // Create a BufferedReader using System.in\n BufferedReader br = new BufferedReader(new \n InputStreamReader(System.in));\n System.out.println(\"Enter characters, \'q\' to quit.\");\n // read characters\n do {\n c = (char) br.read();\n System.out.println(c);\n } while(c != \'q\');\n }\n}\nHere is a sample run:\n\nEnter characters, \'q\' to quit.\n123abcq\n1\n2\n3\na\nb\nc\nq\nReading Strings from Console:\nTo read a string from the keyboard, use the version of readLine( ) that is a member of the BufferedReader class. Its general form is shown here:\n\nString readLine( ) throws IOException\nThe following program demonstrates BufferedReader and the readLine( ) method. The program reads and displays lines of text until you enter the word \"end\":\n\n// Read a string from console using a BufferedReader.\nimport java.io.*;\npublic class BRReadLines {\n public static void main(String args[]) throws IOException\n {\n // Create a BufferedReader using System.in\n BufferedReader br = new BufferedReader(new\n InputStreamReader(System.in));\n String str;\n System.out.println(\"Enter lines of text.\");\n System.out.println(\"Enter \'end\' to quit.\");\n do {\n str = br.readLine();\n System.out.println(str);\n } while(!str.equals(\"end\"));\n }\n}\nHere is a sample run:\n\nEnter lines of text.\nEnter \'end\' to quit.\nThis is line one\nThis is line one\nThis is line two\nThis is line two\nend\nend\nWriting Console Output:\nConsole output is most easily accomplished with print( ) and println( ), described earlier. These methods are defined by the class PrintStream which is the type of the object referenced by System.out. Even though System.out is a byte stream, using it for simple program output is still acceptable.\n\nBecause PrintStream is an output stream derived from OutputStream, it also implements the low-level method write( ). Thus, write( ) can be used to write to the console. The simplest form of write( ) defined by PrintStream is shown here:\n\nvoid write(int byteval)\nThis method writes to the stream the byte specified by byteval. Although byteval is declared as an integer, only the low-order eight bits are written.\n\nExample:\nHere is a short example that uses write( ) to output the character \"A\" followed by a newline to the screen:\n\nimport java.io.*;\n\n// Demonstrate System.out.write().\npublic class WriteDemo {\n public static void main(String args[]) {\n int b; \n b = \'A\';\n System.out.write(b);\n System.out.write(\'\\n\');\n }\n}\nThis would produce simply \'A\' character on the output screen.\n\nA\nNote: You will not often use write( ) to perform console output because print( ) and println( ) are substantially easier to use.\n\nReading and Writing Files:\nAs described earlier, A stream can be defined as a sequence of data. The InputStream is used to read data from a source and the OutputStream is used for writing data to a destination.\n\nHere is a hierarchy of classes to deal with Input and Output streams.\n\nJava I/O Streams\nThe two important streams are FileInputStream and FileOutputStream, which would be discussed in this tutorial:\n\nFileInputStream:\nThis stream is used for reading data from the files. Objects can be created using the keyword new and there are several types of constructors available.\n\nFollowing constructor takes a file name as a string to create an input stream object to read the file.:\n\nInputStream f = new FileInputStream(\"C:/java/hello\");\nFollowing constructor takes a file object to create an input stream object to read the file. First we create a file object using File() method as follows:\n\nFile f = new File(\"C:/java/hello\");\nInputStream f = new FileInputStream(f);\nOnce you have InputStream object in hand, then there is a list of helper methods which can be used to read to stream or to do other operations on the stream.\n\nSN\tMethods with Description\n1\tpublic void close() throws IOException{}\nThis method closes the file output stream. Releases any system resources associated with the file. Throws an IOException.\n2\tprotected void finalize()throws IOException {}\nThis method cleans up the connection to the file. Ensures that the close method of this file output stream is called when there are no more references to this stream. Throws an IOException.\n3\tpublic int read(int r)throws IOException{}\nThis method reads the specified byte of data from the InputStream. Returns an int. Returns the next byte of data and -1 will be returned if it\'s end of file.\n4\tpublic int read(byte[] r) throws IOException{}\nThis method reads r.length bytes from the input stream into an array. Returns the total number of bytes read. If end of file -1 will be returned.\n5\tpublic int available() throws IOException{}\nGives the number of bytes that can be read from this file input stream. Returns an int.\nThere are other important input streams available, for more detail you can refer to the following links:\n\nByteArrayInputStream\n\nDataInputStream\n\nFileOutputStream:\nFileOutputStream is used to create a file and write data into it. The stream would create a file, if it doesn\'t already exist, before opening it for output.\n\nHere are two constructors which can be used to create a FileOutputStream object.\n\nFollowing constructor takes a file name as a string to create an input stream object to write the file:\n\nOutputStream f = new FileOutputStream(\"C:/java/hello\") \nFollowing constructor takes a file object to create an output stream object to write the file. First, we create a file object using File() method as follows:\n\nFile f = new File(\"C:/java/hello\");\nOutputStream f = new FileOutputStream(f);\nOnce you have OutputStream object in hand, then there is a list of helper methods, which can be used to write to stream or to do other operations on the stream.\n\nSN\tMethods with Description\n1\tpublic void close() throws IOException{}\nThis method closes the file output stream. Releases any system resources associated with the file. Throws an IOException.\n2\tprotected void finalize()throws IOException {}\nThis method cleans up the connection to the file. Ensures that the close method of this file output stream is called when there are no more references to this stream. Throws an IOException.\n3\tpublic void write(int w)throws IOException{}\nThis methods writes the specified byte to the output stream.\n4\tpublic void write(byte[] w)\nWrites w.length bytes from the mentioned byte array to the OutputStream.\nThere are other important output streams available, for more detail you can refer to the following links:\n\nByteArrayOutputStream\n\nDataOutputStream\n\nExample:\nFollowing is the example to demonstrate InputStream and OutputStream:\n\nimport java.io.*;\n\npublic class fileStreamTest{\n\n public static void main(String args[]){\n \n try{\n byte bWrite [] = {11,21,3,40,5};\n OutputStream os = new FileOutputStream(\"test.txt\");\n for(int x=0; x < bWrite.length ; x++){\n os.write( bWrite[x] ); // writes the bytes\n }\n os.close();\n \n InputStream is = new FileInputStream(\"test.txt\");\n int size = is.available();\n\n for(int i=0; i< size; i++){\n System.out.print((char)is.read() + \" \");\n }\n is.close();\n }catch(IOException e){\n System.out.print(\"Exception\");\n }\t\n }\n}\nThe above code would create file test.txt and would write given numbers in binary format. Same would be output on the stdout screen.\n\nFile Navigation and I/O:\nThere are several other classes that we would be going through to get to know the basics of File Navigation and I/O.\n\nFile Class\n\nFileReader Class\n\nFileWriter Class\n\nDirectories in Java:\nCreating Directories:\nThere are two useful File utility methods, which can be used to create directories:\n\nThe mkdir( ) method creates a directory, returning true on success and false on failure. Failure indicates that the path specified in the File object already exists, or that the directory cannot be created because the entire path does not exist yet.\n\nThe mkdirs() method creates both a directory and all the parents of the directory.\n\nFollowing example creates \"/tmp/user/java/bin\" directory:\n\nimport java.io.File;\n\npublic class CreateDir {\n public static void main(String args[]) {\n String dirname = \"/tmp/user/java/bin\";\n File d = new File(dirname);\n // Create directory now.\n d.mkdirs();\n }\n}\nCompile and execute above code to create \"/tmp/user/java/bin\".\n\nNote: Java automatically takes care of path separators on UNIX and Windows as per conventions. If you use a forward slash (/) on a Windows version of Java, the path will still resolve correctly.\n\nReading Directories:\nA directory is a File that contains a list of other files and directories. When you create a File object and it is a directory, the isDirectory( ) method will return true.\n\nYou can call list( ) on that object to extract the list of other files and directories inside. The program shown here illustrates how to use list( ) to examine the contents of a directory:\n\nimport java.io.File;\n\npublic class DirList {\n public static void main(String args[]) {\n String dirname = \"/tmp\";\n File f1 = new File(dirname);\n if (f1.isDirectory()) {\n System.out.println( \"Directory of \" + dirname);\n String s[] = f1.list();\n for (int i=0; i < s.length; i++) {\n File f = new File(dirname + \"/\" + s[i]);\n if (f.isDirectory()) {\n System.out.println(s[i] + \" is a directory\");\n } else {\n System.out.println(s[i] + \" is a file\");\n }\n }\n } else {\n System.out.println(dirname + \" is not a directory\");\n }\n }\n}\nThis would produce the following result:\n\nDirectory of /tmp\nbin is a directory\nlib is a directory\ndemo is a directory\ntest.txt is a file\nREADME is a file\nindex.html is a file\ninclude is a directory\"\n\"An exception is a problem that arises during the execution of a program. An exception can occur for many different reasons, including the following:\n\nA user has entered invalid data.\n\nA file that needs to be opened cannot be found.\n\nA network connection has been lost in the middle of communications or the JVM has run out of memory.\n\nSome of these exceptions are caused by user error, others by programmer error, and others by physical resources that have failed in some manner.\n\nTo understand how exception handling works in Java, you need to understand the three categories of exceptions:\n\nChecked exceptions: A checked exception is an exception that is typically a user error or a problem that cannot be foreseen by the programmer. For example, if a file is to be opened, but the file cannot be found, an exception occurs. These exceptions cannot simply be ignored at the time of compilation.\n\nRuntime exceptions: A runtime exception is an exception that occurs that probably could have been avoided by the programmer. As opposed to checked exceptions, runtime exceptions are ignored at the time of compilation.\n\nErrors: These are not exceptions at all, but problems that arise beyond the control of the user or the programmer. Errors are typically ignored in your code because you can rarely do anything about an error. For example, if a stack overflow occurs, an error will arise. They are also ignored at the time of compilation.\n\nException Hierarchy:\nAll exception classes are subtypes of the java.lang.Exception class. The exception class is a subclass of the Throwable class. Other than the exception class there is another subclass called Error which is derived from the Throwable class.\n\nErrors are not normally trapped form the Java programs. These conditions normally happen in case of severe failures, which are not handled by the java programs. Errors are generated to indicate errors generated by the runtime environment. Example : JVM is out of Memory. Normally programs cannot recover from errors.\n\nThe Exception class has two main subclasses: IOException class and RuntimeException Class.\n\nJava Exceptions\nHere is a list of most common checked and unchecked Java\'s Built-in Exceptions.\n\nExceptions Methods:\nFollowing is the list of important medthods available in the Throwable class.\n\nSN\tMethods with Description\n1\tpublic String getMessage()\nReturns a detailed message about the exception that has occurred. This message is initialized in the Throwable constructor.\n2\tpublic Throwable getCause()\nReturns the cause of the exception as represented by a Throwable object.\n3\tpublic String toString()\nReturns the name of the class concatenated with the result of getMessage()\n4\tpublic void printStackTrace()\nPrints the result of toString() along with the stack trace to System.err, the error output stream.\n5\tpublic StackTraceElement [] getStackTrace()\nReturns an array containing each element on the stack trace. The element at index 0 represents the top of the call stack, and the last element in the array represents the method at the bottom of the call stack.\n6\tpublic Throwable fillInStackTrace()\nFills the stack trace of this Throwable object with the current stack trace, adding to any previous information in the stack trace.\nCatching Exceptions:\nA method catches an exception using a combination of the try and catch keywords. A try/catch block is placed around the code that might generate an exception. Code within a try/catch block is referred to as protected code, and the syntax for using try/catch looks like the following:\n\ntry\n{\n //Protected code\n}catch(ExceptionName e1)\n{\n //Catch block\n}\nA catch statement involves declaring the type of exception you are trying to catch. If an exception occurs in protected code, the catch block (or blocks) that follows the try is checked. If the type of exception that occurred is listed in a catch block, the exception is passed to the catch block much as an argument is passed into a method parameter.\n\nExample:\nThe following is an array is declared with 2 elements. Then the code tries to access the 3rd element of the array which throws an exception.\n\n// File Name : ExcepTest.java\nimport java.io.*;\npublic class ExcepTest{\n\n public static void main(String args[]){\n try{\n int a[] = new int[2];\n System.out.println(\"Access element three :\" + a[3]);\n }catch(ArrayIndexOutOfBoundsException e){\n System.out.println(\"Exception thrown :\" + e);\n }\n System.out.println(\"Out of the block\");\n }\n}\nThis would produce the following result:\n\nException thrown :java.lang.ArrayIndexOutOfBoundsException: 3\nOut of the block\nMultiple catch Blocks:\nA try block can be followed by multiple catch blocks. The syntax for multiple catch blocks looks like the following:\n\ntry\n{\n //Protected code\n}catch(ExceptionType1 e1)\n{\n //Catch block\n}catch(ExceptionType2 e2)\n{\n //Catch block\n}catch(ExceptionType3 e3)\n{\n //Catch block\n}\nThe previous statements demonstrate three catch blocks, but you can have any number of them after a single try. If an exception occurs in the protected code, the exception is thrown to the first catch block in the list. If the data type of the exception thrown matches ExceptionType1, it gets caught there. If not, the exception passes down to the second catch statement. This continues until the exception either is caught or falls through all catches, in which case the current method stops execution and the exception is thrown down to the previous method on the call stack.\n\nExample:\nHere is code segment showing how to use multiple try/catch statements.\n\ntry\n{\n file = new FileInputStream(fileName);\n x = (byte) file.read();\n}catch(IOException i)\n{\n i.printStackTrace();\n return -1;\n}catch(FileNotFoundException f) //Not valid!\n{\n f.printStackTrace();\n return -1;\n}\nThe throws/throw Keywords:\nIf a method does not handle a checked exception, the method must declare it using the throws keyword. The throws keyword appears at the end of a method\'s signature.\n\nYou can throw an exception, either a newly instantiated one or an exception that you just caught, by using the throw keyword. Try to understand the different in throws and throw keywords.\n\nThe following method declares that it throws a RemoteException:\n\nimport java.io.*;\npublic class className\n{\n public void deposit(double amount) throws RemoteException\n {\n // Method implementation\n throw new RemoteException();\n }\n //Remainder of class definition\n}\nA method can declare that it throws more than one exception, in which case the exceptions are declared in a list separated by commas. For example, the following method declares that it throws a RemoteException and an InsufficientFundsException:\n\nimport java.io.*;\npublic class className\n{\n public void withdraw(double amount) throws RemoteException,\n InsufficientFundsException\n {\n // Method implementation\n }\n //Remainder of class definition\n}\nThe finally Keyword\nThe finally keyword is used to create a block of code that follows a try block. A finally block of code always executes, whether or not an exception has occurred.\n\nUsing a finally block allows you to run any cleanup-type statements that you want to execute, no matter what happens in the protected code.\n\nA finally block appears at the end of the catch blocks and has the following syntax:\n\ntry\n{\n //Protected code\n}catch(ExceptionType1 e1)\n{\n //Catch block\n}catch(ExceptionType2 e2)\n{\n //Catch block\n}catch(ExceptionType3 e3)\n{\n //Catch block\n}finally\n{\n //The finally block always executes.\n}\nExample:\npublic class ExcepTest{\n\n public static void main(String args[]){\n int a[] = new int[2];\n try{\n System.out.println(\"Access element three :\" + a[3]);\n }catch(ArrayIndexOutOfBoundsException e){\n System.out.println(\"Exception thrown :\" + e);\n }\n finally{\n a[0] = 6;\n System.out.println(\"First element value: \" +a[0]);\n System.out.println(\"The finally statement is executed\");\n }\n }\n}\nThis would produce the following result:\n\nException thrown :java.lang.ArrayIndexOutOfBoundsException: 3\nFirst element value: 6\nThe finally statement is executed\nNote the following:\n\nA catch clause cannot exist without a try statement.\n\nIt is not compulsory to have finally clauses when ever a try/catch block is present.\n\nThe try block cannot be present without either catch clause or finally clause.\n\nAny code cannot be present in between the try, catch, finally blocks.\n\nDeclaring you own Exception:\nYou can create your own exceptions in Java. Keep the following points in mind when writing your own exception classes:\n\nAll exceptions must be a child of Throwable.\n\nIf you want to write a checked exception that is automatically enforced by the Handle or Declare Rule, you need to extend the Exception class.\n\nIf you want to write a runtime exception, you need to extend the RuntimeException class.\n\nWe can define our own Exception class as below:\n\nclass MyException extends Exception{\n}\nYou just need to extend the Exception class to create your own Exception class. These are considered to be checked exceptions. The following InsufficientFundsException class is a user-defined exception that extends the Exception class, making it a checked exception. An exception class is like any other class, containing useful fields and methods.\n\nExample:\n// File Name InsufficientFundsException.java\nimport java.io.*;\n\npublic class InsufficientFundsException extends Exception\n{\n private double amount;\n public InsufficientFundsException(double amount)\n {\n this.amount = amount;\n } \n public double getAmount()\n {\n return amount;\n }\n}\nTo demonstrate using our user-defined exception, the following CheckingAccount class contains a withdraw() method that throws an InsufficientFundsException.\n\n// File Name CheckingAccount.java\nimport java.io.*;\n\npublic class CheckingAccount\n{\n private double balance;\n private int number;\n public CheckingAccount(int number)\n {\n this.number = number;\n }\n public void deposit(double amount)\n {\n balance += amount;\n }\n public void withdraw(double amount) throws\n InsufficientFundsException\n {\n if(amount <= balance)\n {\n balance -= amount;\n }\n else\n {\n double needs = amount - balance;\n throw new InsufficientFundsException(needs);\n }\n }\n public double getBalance()\n {\n return balance;\n }\n public int getNumber()\n {\n return number;\n }\n}\nThe following BankDemo program demonstrates invoking the deposit() and withdraw() methods of CheckingAccount.\n\n// File Name BankDemo.java\npublic class BankDemo\n{\n public static void main(String [] args)\n {\n CheckingAccount c = new CheckingAccount(101);\n System.out.println(\"Depositing $500...\");\n c.deposit(500.00);\n try\n {\n System.out.println(\"\\nWithdrawing $100...\");\n c.withdraw(100.00);\n System.out.println(\"\\nWithdrawing $600...\");\n c.withdraw(600.00);\n }catch(InsufficientFundsException e)\n {\n System.out.println(\"Sorry, but you are short $\"\n + e.getAmount());\n e.printStackTrace();\n }\n }\n}\nCompile all the above three files and run BankDemo, this would produce the following result:\n\nDepositing $500...\n\nWithdrawing $100...\n\nWithdrawing $600...\nSorry, but you are short $200.0\nInsufficientFundsException\n at CheckingAccount.withdraw(CheckingAccount.java:25)\n at BankDemo.main(BankDemo.java:13)\nCommon Exceptions:\nIn Java, it is possible to define two catergories of Exceptions and Errors.\n\nJVM Exceptions: - These are exceptions/errors that are exclusively or logically thrown by the JVM. Examples : NullPointerException, ArrayIndexOutOfBoundsException, ClassCastException,\n\nProgrammatic exceptions: - These exceptions are thrown explicitly by the application or the API programmers Examples: IllegalArgumentException, IllegalStateException.\n\n\" };\n\t\n\tString filename=\"file\";\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\t// TODO Auto-generated method stub\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.lang);\n\t\tString aa;\n\t\tSharedPreferences bookmark;\n\t\tt = (TextView) findViewById(R.id.maintext);\n\t\tt1 = (TextView) findViewById(R.id.heading);\n\t\tt1.setTextColor(Color.RED);\n\t\t prev = (Button) findViewById(R.id.prev);\n\t\t next = (Button) findViewById(R.id.next);\n\t\t booksave=(Button)findViewById(R.id.booksave);\n\t\t bookdisplay=(Button)findViewById(R.id.bookdisplay);\n\t\t sd=(SlidingDrawer)findViewById(R.id.sld1);\n\t\t sd.setOnDrawerOpenListener(this);\n\t\t sd.setOnDrawerCloseListener(this);\n\t\t booksave.setOnClickListener(this);\n\t\t bookdisplay.setOnClickListener(this);\n\t\t prev.setOnClickListener(this);\n\t\t next.setOnClickListener(this);\n\t\t \n\t\t bookmark=getSharedPreferences(filename,0);\n\n\n\t\t\tSharedPreferences getpref=PreferenceManager.getDefaultSharedPreferences(getBaseContext());\n\t\t\tString fsize=getpref.getString(\"fsize\", \"s1\") ;\n\t\t\tString fcolor=getpref.getString(\"fcolor\", \"Black\") ;\n\t\t\t\n\t\t\t\tif(fsize.contentEquals(\"s1\"))\n\t\t\t{\n\t\t\t\tt.setTextSize(25);\n\t\t\t}\n\t\t\t\n\t\t\telse if(fsize.contentEquals(\"s2\"))\n\t\t\t{\n\t\t\t\tt.setTextSize(30);\n\t\t\t}\n\n\t\t\telse if(fsize.contentEquals(\"s3\"))\n\t\t\t{\n\t\t\t\tt.setTextSize(35);\n\t\t\t}\n\n\t\t\telse if(fsize.contentEquals(\"s4\"))\n\t\t\t{\n\t\t\t\tt.setTextSize(40);\n\t\t\t}\n\n\t\t\telse if(fsize.contentEquals(\"s5\"))\n\t\t\t{\n\t\t\t\tt.setTextSize(45);\n\t\t\t}\n\n\t\t\telse if(fsize.contentEquals(\"s6\"))\n\t\t\t{\n\t\t\t\tt.setTextSize(50);\n\t\t\t}\n\n\t\t\t\tif(fcolor.contentEquals(\"Black\"))\n\t\t\t{\n\t\t\t\tt.setTextColor(Color.BLACK);\n\t\t\t}\n\t\t\t\n\t\t\telse if(fcolor.contentEquals(\"Blue\"))\n\t\t\t{\n\t\t\t\tt.setTextColor(Color.BLUE);\n\t\t\t}\n\n\t\t\telse if(fcolor.contentEquals(\"Red\"))\n\t\t\t{\n\t\t\t\tt.setTextColor(Color.RED);\n\t\t\t}\n\t\t\telse if(fcolor.contentEquals(\"Cyan\"))\n\t\t\t{\n\t\t\t\tt.setTextColor(Color.CYAN);\n\t\t\t}\n\t\t\telse if(fcolor.contentEquals(\"Gray\"))\n\t\t\t{\n\t\t\t\tt.setTextColor(Color.GRAY);\n\t\t\t}\n\t\t\telse if(fcolor.contentEquals(\"Green\"))\n\t\t\t{\n\t\t\t\tt.setTextColor(Color.GREEN);\n\t\t\t}\n\t\t\n\n\t\t\t\tBundle gotbasket = getIntent().getExtras();\n\t\t\t\tvar = gotbasket.getString(\"a1\");\n\t\t\t\t \n\t\twhile(ii < 5){\n\t\n\t\t\tString ss = optionsc[ii];\n\t\t\tif (var.equals(ss))\n\t\t\t{\n\n\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tii++;\n\t\t\t}\n\t\t}\n\t\tt.setText(optionscvalues[ii]);\n\t\tt1.setText(optionsc[ii]);\n\t\t\n\t\t\n\n\t\t\n\t\t\n\n\t}\n\t\n\n\t\n\t@Override\n\tpublic void onClick(View v) {\n\t\t// TODO Auto-generated method stub\n\t\tswitch(v.getId())\n\t\t{\n\t\tcase R.id.prev:\n\t\t\t\n\t\t\tii--;\n\t\t\tif(ii<0)\n\t\t\t{\n\t\t\t\tii=(optionsc.length)-1;\n\t\t\t}\n\t\t\tt.setText(optionscvalues[ii]);\n\t\t\tt1.setText(optionsc[ii]);\n\t\t\tbreak;\n\t\tcase R.id.next:\n\t\t\t\n\t\t\tii++;\n\t\t\tif(ii>((optionsc.length)-1))\n\t\t\t{\n\t\t\t\tii=0;\n\t\t\t}\n\n\t\t\tt.setText(optionscvalues[ii]);\n\t\t\tt1.setText(optionsc[ii]);\n\t\t\tbreak;\n\t\t\t\n\t\tcase R.id.booksave :\n\t\t\tint jx;\n\t\t\t jx=ii;\n\t\t\t String bookvalue=Integer.toString(jx);\n\t\t\t bookmark=getSharedPreferences(filename,0);\n\t\t\t String bm=bookmark.getString(\"starting\", \"\");\n\t\t\t String cm=bookmark.getString(\"pass\", \"\");\n\t\t\t database12 sd= new database12(this);\n\t\t\t sd.open();\n\t\t\t int f=sd.updateEntry(bm,cm,bookvalue);\n\t\t\t sd.close();\n\t\t\t //t.setText(bm + \"and \" +cm );\n\t\t\t \n\t\t\t\t/*\t\t\tint start=s.indexOf(\"\");\n\t\t\t\tString startingname=s.substring(start); */\n\t\t\t if(f==1)\n\t\t\t {\n\t\t\tToast toast = Toast.makeText(langreader.this, \"bookmark page saved\",Toast.LENGTH_LONG);\t\n\t\t\ttoast.show();\n\t\t\t }\n\n\t\t\tbreak;\n\t\t\n\t\tcase R.id.bookdisplay :\n\t\t\t bookmark=getSharedPreferences(filename,0);\n\t\t\t String bm1=bookmark.getString(\"starting\", \"\");\n\t\t\t String cm1=bookmark.getString(\"pass\", \"\");\n\n\t\t\t database12 sd1= new database12(this);\n\t\t\t sd1.open();\n\t\t\t String fa=sd1.validatebookc(bm1,cm1);\n\t\t\t sd1.close();\n\t\t\t int y=Integer.parseInt(fa);\n\n\t\t\t\n\t\t\tt.setText(optionscvalues[y]);\n\t\t\tt1.setText(optionsc[y]);\n\n\n\t\t\tToast toast1 = Toast.makeText(langreader.this, \"bookmark page opened\",Toast.LENGTH_LONG);\t\t\t\n\t\t\ttoast1.show(); \n\n\t\t\tbreak;\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\n\n\n\t@Override\n\tpublic void onDrawerOpened() {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t\tMediaPlayer Oursong=MediaPlayer.create(langreader.this, R.raw.slider);\n\t\tOursong.start();\n\n\t\t\n\t}\n\n\n\n\t@Override\n\tpublic void onDrawerClosed() {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t\tMediaPlayer Oursong=MediaPlayer.create(langreader.this, R.raw.slider);\n\t\tOursong.start();\n\n\t\t\n\t}\n\t\n\t\n\t\n\t\n\t\n\n\t\n\t/*\n\t\n\n\n\tpublic boolean onCreateOptionsMenu(android.view.Menu menu) {\n\t\t// TODO Auto-generated method stub\n\t\tsuper.onCreateOptionsMenu(menu);\n\t\tMenuInflater blowup=getMenuInflater();\n\t\tblowup.inflate(R.menu.main, menu);\n\t\treturn true;\n\t}\n\n\n\n\n\n\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\t// TODO Auto-generated method stub\n\t\t//return super.onOptionsItemSelected(item);\n\t\tswitch(item.getItemId())\n\t\t{\n\t\tcase (R.id.about):\n\t\tIntent i=new Intent(\"net.com.example.pll.ABOUTUS\");\n\t\tstartActivity(i);\n\t\tbreak;\n\t\t\n\t\tcase (R.id.pref):\n\t\t\tIntent s=new Intent(\"net.com.example.pll.PREFFS\");\n\t\t\tstartActivity(s);\n\t\t\t\n\t\t\tbreak;\n\t\tcase (R.id.exit):\n\t\t\tfinish();\n\t\t}\n\t\treturn false;\n\t}*/\n\n\t\n\t\n\t\n}" };
	
	String filename="file";
	FileOutputStream fos;
	WakeLock wl;
	@Override
	protected void onCreate(Bundle savedInstanceState) {
		// TODO Auto-generated method stub
	/*	SharedPreferences getprefs=PreferenceManager.getDefaultSharedPreferences(getBaseContext());
		boolean lock=getprefs.getBoolean("wlock", false);
		
		if(lock==true)
		{
			PowerManager pm=(PowerManager)getSystemService(Context.POWER_SERVICE); 
			wl=pm.newWakeLock(PowerManager.FULL_WAKE_LOCK, "what");
		}
*/
		super.onCreate(savedInstanceState);
		fscreen();
	//	wl.acquire();
		setContentView(R.layout.lang);
		String aa;
		SharedPreferences bookmark;
		t = (TextView) findViewById(R.id.maintext);
		t1 = (TextView) findViewById(R.id.heading);
		editnotes=(EditText)findViewById(R.id.editnotes);
		t1.setTextColor(Color.RED);
		 prev = (Button) findViewById(R.id.prev);
		 next = (Button) findViewById(R.id.next);
		 booksave=(Button)findViewById(R.id.booksave);
		 savenotes=(Button)findViewById(R.id.savenotes);
		 displaynotes=(Button)findViewById(R.id.displaynotes);
		 bookdisplay=(Button)findViewById(R.id.bookdisplay);
		 sd=(SlidingDrawer)findViewById(R.id.sld1);
		 sd.setOnDrawerOpenListener(this);
		 sd.setOnDrawerCloseListener(this);
		 booksave.setOnClickListener(this);
		 bookdisplay.setOnClickListener(this);
		 prev.setOnClickListener(this);
		 next.setOnClickListener(this);
		 savenotes.setOnClickListener(this);
		 displaynotes.setOnClickListener(this);
	     ActionBar actionBar1 = getActionBar();
	     actionBar1.setDisplayHomeAsUpEnabled(true);
		 
		 
		 
		 try {
			fos=openFileOutput("abcd",MODE_PRIVATE | MODE_APPEND);
			fos.close();
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

		 
		 
		 bookmark=getSharedPreferences(filename,0);
				Bundle gotbasket = getIntent().getExtras();
				var = gotbasket.getString("a1");
				 
		while(ii < 10){
	
			String ss = optionsc[ii];
			if (var.equals(ss))
			{

			break;
			}
			else
			{
				ii++;
			}
		}
		t.setText(optionscvalues[ii]);
		t1.setText(optionsc[ii]);
		getcolor();
		getsize();

		
		

		
		

	}
	

	
	private void getsize() {
		// TODO Auto-generated method stub
		
		
		SharedPreferences getpref=PreferenceManager.getDefaultSharedPreferences(getBaseContext());
		String fsize=getpref.getString("fsize", "s1") ;

		
			if(fsize.contentEquals("s1"))
		{
			t.setTextSize(25);
		}
		
		else if(fsize.contentEquals("s2"))
		{
			t.setTextSize(30);
		}

		else if(fsize.contentEquals("s3"))
		{
			t.setTextSize(35);
		}

		else if(fsize.contentEquals("s4"))
		{
			t.setTextSize(40);
		}

		else if(fsize.contentEquals("s5"))
		{
			t.setTextSize(45);
		}

		else if(fsize.contentEquals("s6"))
		{
			t.setTextSize(50);
		}


		
	}


	void fscreen() {
		// TODO Auto-generated method stub
	
	SharedPreferences getprefs=PreferenceManager.getDefaultSharedPreferences(getBaseContext());
	boolean screen=getprefs.getBoolean("fscreen", false);
	
	if(screen==true)
	{
		requestWindowFeature(Window.FEATURE_NO_TITLE);
		getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,WindowManager.LayoutParams.FLAG_FULLSCREEN);

	}

		
	}

	
	private void getcolor() {
		// TODO Auto-generated method stub
		
		SharedPreferences getpref=PreferenceManager.getDefaultSharedPreferences(getBaseContext());
		String fcolor=getpref.getString("fcolor", "Black") ;
		
		
		if(fcolor.contentEquals("Black"))
	{
		t.setTextColor(Color.BLACK);
	}
	
	else if(fcolor.contentEquals("Blue"))
	{
		t.setTextColor(Color.BLUE);
	}

	else if(fcolor.contentEquals("Red"))
	{
		t.setTextColor(Color.RED);
	}
	else if(fcolor.contentEquals("Cyan"))
	{
		t.setTextColor(Color.CYAN);
	}
	else if(fcolor.contentEquals("Gray"))
	{
		t.setTextColor(Color.GRAY);
	}
	else if(fcolor.contentEquals("Green"))
	{
		t.setTextColor(Color.GREEN);
	}
		
		
	}



	@Override
	public void onClick(View v) {
		// TODO Auto-generated method stub
		switch(v.getId())
		{
		case R.id.prev:
			
			ii--;
			if(ii<0)
			{
				ii=(optionsc.length)-1;
			}
			t.setText(optionscvalues[ii]);
			t1.setText(optionsc[ii]);
			getcolor();
			getsize();
			  Vibrator v12 = (Vibrator)getSystemService(Context.VIBRATOR_SERVICE);
			  v12.vibrate(100);

			break;
		case R.id.next:
			
			ii++;
			if(ii>((optionsc.length)-1))
			{
				ii=0;
			}

			t.setText(optionscvalues[ii]);
			t1.setText(optionsc[ii]);
			getcolor();
			getsize();
			  Vibrator v121 = (Vibrator)getSystemService(Context.VIBRATOR_SERVICE);
			  v121.vibrate(100);

			break;
			
		case R.id.booksave :
			int jx;
			 jx=ii;
			 String bookvalue=Integer.toString(jx);
			 bookmark=getSharedPreferences(filename,0);
			 String bm=bookmark.getString("starting", "");
			 String cm=bookmark.getString("pass", "");
			 database12 sd= new database12(this);
			 sd.open();
			 int f=sd.updateEntryjava(bm,cm,bookvalue);
			 sd.close();
			 //t.setText(bm + "and " +cm );
			 
				/*			int start=s.indexOf("");
				String startingname=s.substring(start); */
			 if(f==1)
			 {
			Toast toast = Toast.makeText(langreader2.this, "bookmark page saved",Toast.LENGTH_LONG);	
			toast.show();
			 }

			break;
		
		case R.id.bookdisplay :
			 bookmark=getSharedPreferences(filename,0);
			 String bm1=bookmark.getString("starting", "");
			 String cm1=bookmark.getString("pass", "");

			 database12 sd1= new database12(this);
			 sd1.open();
			 String fa=sd1.validatebookjava(bm1,cm1);
			 sd1.close();
			 int y=Integer.parseInt(fa);

			
			t.setText(optionscvalues[y]);
			t1.setText(optionsc[y]);


			Toast toast1 = Toast.makeText(langreader2.this, "bookmark page opened",Toast.LENGTH_LONG);			
			toast1.show();   

			break;
			
		case R.id.savenotes :
			 String timezoneID = TimeZone.getDefault().getID();
			/* SimpleDateFormat sdf2 = new SimpleDateFormat("dd-MMM-yyyy");
			 sdf2.setTimeZone(TimeZone.getTimeZone(timezoneID));*/
			 
		//	 Log.d("Time zone","="+tz.getDisplayName());
		//	 String time = "";
			 TimeZone tz = TimeZone.getTimeZone("GMT+05:30");
			 Calendar c = Calendar.getInstance(tz);
		//	 String d=c.get(Calendar.DATE);
			 
			 String time = "DATE :"+c.get(Calendar.DATE)+ " "+/*c.get(Calendar.NOVEMBER)*/"11" +"  "+c.get(Calendar.YEAR) 
					 +"   TIME : "+c.get(Calendar.HOUR_OF_DAY)+":"+c.get(Calendar.MINUTE)+":"+c.get(Calendar.SECOND);
			 data="JAVA LANGUAGE"+"\n"+time + "\n" + editnotes.getText().toString() + "\n\n";
			 bookmark=getSharedPreferences(filename,0);
			 String bm2=bookmark.getString("starting","");
			 String cm2=bookmark.getString("pass","");
			 String dm2=bm2.concat(cm2);
			 
		     

			try {
				fos=openFileOutput(dm2,MODE_PRIVATE | MODE_APPEND);
				fos.write(data.getBytes());
				fos.close();

			} catch (FileNotFoundException e) {
				// TODO Auto-generated catch block
				
				e.printStackTrace();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
				
			}

			Toast toast111 = Toast.makeText(langreader2.this, "Notes Saved",Toast.LENGTH_LONG);			
			toast111.show();   
			editnotes.setText("");
			
			break;
			
		case R.id.displaynotes :
			
			String collected=null;
			FileInputStream fis=null;
			 bookmark=getSharedPreferences(filename,0);
			 String bm4=bookmark.getString("starting", "");
			 String cm4=bookmark.getString("pass", "");
			 String dm4=bm4.concat(cm4);

			try {
				fis=openFileInput(dm4);
				byte[] dataArray =new byte[fis.available()];
				while(fis.read(dataArray)!=-1)
				{
					collected=new String(dataArray);
				}
			} catch (FileNotFoundException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
			finally
			{
				try {
					fis.close();
				} catch (IOException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
			}
			
			Bundle basket=new Bundle();
			basket.putString("collect", collected);
			Intent a=new Intent(langreader2.this,displaynotes.class);
			a.putExtras(basket);
			startActivity(a);	

			Toast toast134 = Toast.makeText(langreader2.this, "Here's Your Notes",Toast.LENGTH_LONG);			
			toast134.show();   

			
			
			break;


		}
	}



	@Override
	public void onDrawerOpened() {
		// TODO Auto-generated method stub
		
		MediaPlayer Oursong=MediaPlayer.create(langreader2.this, R.raw.slider);
		Oursong.start();

		
	}



	@Override
	public void onDrawerClosed() {
		// TODO Auto-generated method stub
		
		MediaPlayer Oursong=MediaPlayer.create(langreader2.this, R.raw.slider);
		Oursong.start();

		
	}
	
	
	
	
	

	
	
	


	public boolean onCreateOptionsMenu(android.view.Menu menu) {
		// TODO Auto-generated method stub
		super.onCreateOptionsMenu(menu);
		MenuInflater blowup=getMenuInflater();
		blowup.inflate(R.menu.main, menu);
		return true;
	}






	public boolean onOptionsItemSelected(MenuItem item) {
		// TODO Auto-generated method stub
		//return super.onOptionsItemSelected(item);
		switch(item.getItemId())
		{
		case (R.id.about):
		Intent i=new Intent("net.com.example.pllv1.ABOUTUS");
		startActivity(i);
		break;
		
		case (R.id.pref):
			Intent s=new Intent("net.com.example.pllv1.PREFFS");
			startActivity(s);
			
			break;
		case (R.id.exit):
			//finish();
			System.exit(0);
		default:         startActivity(new Intent(langreader2.this,java.class));
		}
		return false;
	}



	@Override
	protected void onPause() {
		// TODO Auto-generated method stub
		super.onPause();
//		wl.release();
	}

	
	
	
}
